<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSP Node Graph: Reverb Lab</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --node-bg: #2d2d2d;
            --node-header: #404040;
            --text: #e0e0e0;
            --accent: #00d2ff;
            --accent-hover: #33ddff;
            --input: #ff4d4d;
            --output: #4dff88;
        }


        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            z-index: 10;
            pointer-events: none;
        }

        .node-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            pointer-events: auto;
            flex: 1 1 auto;
        }

        .action-group {
            display: flex;
            gap: 6px;
            align-items: center;
            pointer-events: auto;
            flex: 0 0 auto;
            white-space: nowrap;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #555;
            margin: 0 4px;
            pointer-events: none;
        }

        button,
        .file-btn,
        select {
            pointer-events: auto;
            background: var(--node-bg);
            border: 1px solid #555;
            color: var(--text);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-decoration: none;
            display: inline-block;
        }

        button:hover,
        .file-btn:hover,
        select:hover {
            background: var(--node-header);
            border-color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            color: #000;
            border: none;
        }

        button.primary:hover {
            background: var(--accent-hover);
        }

        select {
            width: 120px;
            outline: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            pointer-events: none;
            color: #666;
            font-size: 12px;
            text-shadow: 0 1px 2px #000;
        }

        /* Custom file input hidden */
        #file-input {
            display: none;
        }
    </style>
</head>

<body>

    <div id="toolbar">
        <div class="node-group">
            <button id="btn-start" class="primary">Start Audio Engine</button>
            <div class="toolbar-separator"></div>
            <button onclick="app.addNode('audio-source')">Audio Source</button>
            <button onclick="app.addNode('gain')">Gain</button>
            <button onclick="app.addNode('mixer')">Mixer</button>
            <button onclick="app.addNode('wetdry')">Wet/Dry</button>
            <button onclick="app.addNode('panner')">Panner</button>
            <button onclick="app.addNode('delay')">Delay</button>
            <button onclick="app.addNode('comb')">Comb (FB)</button>
            <button onclick="app.addNode('allpass-delay')">Allpass (Delay)</button>
            <button onclick="app.addNode('allpass')">Allpass (Biquad)</button>
            <button onclick="app.addNode('diffuser')">Diffuser</button>
            <button onclick="app.addNode('fdn-scalable')">FDN (Feedback delay network)</button>
            <button onclick="app.addNode('lpf')">LPF</button>
            <button onclick="app.addNode('hpf')">HPF</button>
            <button onclick="app.addNode('bpf')">Band Pass</button>
            <button onclick="app.addNode('notch')">Notch</button>
            <button onclick="app.addNode('ringmod')">Ring Mod</button>
            <button onclick="app.addNode('pitch-shifter')">Pitch Shifter</button>
            <button onclick="app.addNode('mono')">Mono</button>
            <button onclick="app.addNode('distortion')">Distortion</button>
            <button onclick="app.addNode('adder')">Adder</button>
            <button onclick="app.addNode('multiply')">Multiply</button>
            <button onclick="app.addNode('inverter')">Inverter</button>
            <button onclick="app.addNode('abs')">Absolute</button>
            <button onclick="app.addNode('value')">Value</button>
            <button onclick="app.addNode('samplehold')">Sample &amp; Hold</button>
            <button onclick="app.addNode('lfo')">LFO</button>
            <button onclick="app.addNode('chaos')">Chaos</button>
        </div>
        <div class="action-group">
            <select id="preset-select" onchange="app.loadPreset(this.value); this.value='';">
                <option value="" disabled selected>Presets...</option>
                <option value="shroeder-topology">Schroeder Topology</option>
                <option value="quadraverb-topology">Quadraverb Topology</option>
                <option value="ping-pong-delay">Ping Pong Delay</option>
            </select>
            <button onclick="app.saveGraph()">Save</button>
            <button onclick="document.getElementById('json-input').click()">Load</button>
            <button onclick="app.reset()">Clear</button>
            <button id="btn-toggle-delay-units">Delay Units: ms</button>
        </div>
    </div>

    <!-- Hidden Inputs for File Loading -->
    <input type="file" id="json-input" accept=".json" onchange="app.loadGraph(this)" style="display:none">
    <input type="file" id="audio-input" accept="audio/*" style="display:none">

    <div id="canvas-container">
        <canvas id="nodeCanvas"></canvas>
    </div>

    <div id="overlay">
        Right-click cable: Cycle mode • Mid-click drag: Pan • Dbl-click line: Disconnect • Drag ports: Connect • Delete:
        Remove selection • Ctrl+D: Duplicate selection • Spacebar: Re-trigger Source • Q-P: Chromatic notes • 2/3/5/6/7/9/0: Sharps • +/-: Octave
        shift • Delay Units button: Toggle ms/samples • Mic button: Toggle live input • Yellow ports: Parameter scale
        inputs
    </div>

    <script>
        /* * AUDIO SYNTHESIS UTILS */
        const AudioUtils = {
            ctx: null,
            init(ctx) { this.ctx = ctx; },

            createNoise(duration = 1.0) {
                if (!this.ctx) return null;
                const size = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, size, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < size; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            },

            // Helper math for log sliders
            toLog(position, min, max) {
                // position 0..1
                const minv = Math.log(min);
                const maxv = Math.log(max);
                const scale = maxv - minv;
                return Math.exp(minv + scale * position);
            },

            fromLog(value, min, max) {
                // value min..max -> returns 0..1
                const minv = Math.log(min);
                const maxv = Math.log(max);
                const scale = maxv - minv;
                return (Math.log(value) - minv) / scale;
            }
        };

        /* * NODE GRAPH ENGINE */

        class DSPNode {
            constructor(x, y, title, app) {
                this.id = crypto.randomUUID();
                this.x = x;
                this.y = y;
                this.width = 140;
                this.title = title;
                this.app = app;
                this.inputs = [];  // {name, id, node: AudioNode}
                this.outputs = []; // {name, id, node: AudioNode}
                this.params = [];  // {label, type, value, min, max, scale, onChange}
                this.paramInputs = []; // [{name, id, paramIndex}]
                this.paramModulators = []; // Array of [{node}]
                this.paramSpacing = 40;

                this.headerHeight = 25;
                this.bodyHeight = 0;
                this.dragOffset = { x: 0, y: 0 };
            }

            computeHeight() {
                const perParam = this.paramSpacing || 40;
                const paramH = this.params.length * perParam;
                const ioH = Math.max(this.inputs.length, this.outputs.length) * 20;
                // Add extra space for specific nodes
                const isAudioSource = this.type === 'audio-source' || this.type === 'sampler';
                let extra = isAudioSource ? 160 : (this.type === 'output' ? 20 : 0);
                this.bodyHeight = extra + paramH + ioH;
                this.height = this.headerHeight + this.bodyHeight;
            }

            initAudio(ctx) { } // Override

            setupParameterIO() {
                if (!this.params) return;
                this.paramInputs = this.params.map((p, idx) => ({
                    name: p.label ? `${p.label} Scale` : 'Scale',
                    id: idx,
                    paramIndex: idx
                }));
                if (!this.paramModulators) this.paramModulators = [];
                this.params.forEach((_, idx) => {
                    if (!this.paramModulators[idx]) this.paramModulators[idx] = [];
                });
            }

            getParamInputPos(index) {
                const slotTop = this.getParamSlotTop(index);
                const portOffset = 28;
                return {
                    x: this.x,
                    y: slotTop + portOffset
                };
            }

            updateParam(index) {
                const param = this.params && this.params[index];
                if (!param || typeof param.onChange !== 'function') return;
                const mods = (this.paramModulators && this.paramModulators[index]) || [];
                const modEntries = mods
                    .map(entry => {
                        if (!entry || !entry.node || typeof entry.node.getValue !== 'function') return null;
                        const value = entry.node.getValue();
                        if (typeof value !== 'number' || !isFinite(value)) return null;
                        const mode = entry.mode || param.modulationStrategy || 'multiply';
                        return { value, mode };
                    })
                    .filter(Boolean);
                let effective = param.value;
                if (modEntries.length) {
                    let overrideValue = null;
                    let additiveSum = 0;
                    let multiplicativeProduct = 1;
                    modEntries.forEach(({ value, mode }) => {
                        if (mode === 'override') {
                            overrideValue = value;
                        } else if (mode === 'add') {
                            additiveSum += value;
                        } else {
                            multiplicativeProduct *= value;
                        }
                    });
                    if (overrideValue !== null) {
                        effective = overrideValue;
                    } else {
                        const base = typeof param.value === 'number' ? param.value : 0;
                        effective = (base * multiplicativeProduct) + additiveSum;
                    }
                }
                const meta = { fromAutomation: modEntries.length > 0 };
                param.onChange(effective, meta);
                param.effectiveValue = effective;
            }

            removeParamModulator(index, node) {
                if (!this.paramModulators || !this.paramModulators[index]) return;
                this.paramModulators[index] = this.paramModulators[index].filter(entry => entry.node !== node);
            }

            initializeParams() {
                this.setupParameterIO();
                if (!this.params) return;
                this.params.forEach(param => {
                    if (param.defaultValue === undefined) {
                        param.defaultValue = param.value;
                    }
                    const strategy = param.modulationStrategy || 'multiply';
                    param.modulationStrategy = strategy;
                    if (param.defaultModulationStrategy === undefined) {
                        param.defaultModulationStrategy = strategy;
                    }
                });
                this.params.forEach((_, idx) => this.updateParam(idx));
            }

            getParamSlotTop(index) {
                const baseOffset = (this.type === 'audio-source' || this.type === 'sampler') ? 100 : 14;
                const spacing = this.paramSpacing || 40;
                return this.y + this.headerHeight + baseOffset + (index * spacing);
            }

            getSnapshot() {
                const snapshot = {
                    id: this.id,
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    params: this.params.map(p => p.value)
                };
                const extra = this.getExtraData();
                if (extra && Object.keys(extra).length > 0) {
                    snapshot.extra = extra;
                }
                return snapshot;
            }

            getExtraData() {
                if (!this.params || !this.params.length) return null;
                const overrides = [];
                this.params.forEach((param, idx) => {
                    const defaultStrategy = param.defaultModulationStrategy || 'multiply';
                    const currentStrategy = param.modulationStrategy || 'multiply';
                    if (currentStrategy !== defaultStrategy) {
                        overrides.push({ index: idx, strategy: currentStrategy });
                    }
                });
                return overrides.length ? { paramStrategies: overrides } : null;
            }

            restoreExtraData(data) {
                if (!data || !this.params) return;
                const strategies = Array.isArray(data.paramStrategies)
                    ? data.paramStrategies
                    : (data.paramStrategies ? [data.paramStrategies] : []);
                strategies.forEach(entry => {
                    const { index, strategy } = entry || {};
                    if (typeof index === 'number' && this.params[index]) {
                        this.params[index].modulationStrategy = strategy || 'multiply';
                    }
                });
            }

            isPointInside(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                    y >= this.y && y <= this.y + this.height;
            }

            getPortPos(isInput, index) {
                if (isInput && this.params && this.params.length > 0 && index < this.params.length) {
                    const slotTop = this.getParamSlotTop(index);
                    return {
                        x: this.x,
                        y: slotTop + 8
                    };
                }

                const baseY = this.y + (this.headerHeight * 0.5);
                const spacing = 18;
                const y = baseY + (index * spacing);
                const x = isInput ? this.x : this.x + this.width;
                return { x, y };
            }
        }

        /* * SPECIFIC NODE IMPLEMENTATIONS */

        class OutputNode extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Stereo Output', app);
                this.type = 'output';
                this.width = 140;
                this.analyser = null;
                this.visualData = null;
            }

            initAudio(ctx) {
                this.tag = Math.random().toString(36).slice(2, 6);
                this.analyser = ctx.createAnalyser();
                this.analyser._debugLabel = `Output Node - Analyser [${this.tag}]`;
                this.analyser.fftSize = 256;
                this.visualData = new Uint8Array(this.analyser.frequencyBinCount);

                this.limiter = ctx.createDynamicsCompressor();
                this.limiter._debugLabel = `Output Node - Limiter [${this.tag}]`;
                this.limiter.threshold.value = -1;
                this.limiter.ratio.value = 20;

                this.analyser.connect(this.limiter);
                this.limiter.connect(ctx.destination);

                this.inputs = [{ name: 'L/R', id: 0, node: this.analyser }];
                this.computeHeight();
            }
        }

        class AudioSourceNode extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Audio Source', app);
                this.type = 'audio-source';
                this.width = 210;
                this.paramSpacing = 40;
                this.customBuffer = null;
                this.lastType = 'kick'; // For spacebar
                this.baseFrequency = 440;
                this.basePlaybackRate = 1;
                this.noteRelease = 0.3;
                this.micStream = null;
                this.micSource = null;
                this.micActive = false;
                this.micPending = false;
                this.micError = null;
            }

            initAudio(ctx) {
                this.tag = Math.random().toString(36).slice(2, 6);
                this.outNode = ctx.createGain();
                this.outNode._debugLabel = `Audio Source Out [${this.tag}]`;
                this.outputs = [{ name: 'Out', id: 0, node: this.outNode }];
                this.computeHeight();
            }

            isTypePitchable(type) {
                if (type === 'custom') return !!this.customBuffer;
                return type === 'sine' || type === 'saw' || type === 'square' || type === 'triangle';
            }

            isPitchable() {
                return this.isTypePitchable(this.lastType);
            }

            playOscillator(type, frequency, duration = this.noteRelease) {
                const ctx = this.app.audioCtx;
                if (!ctx) return;
                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                osc._debugLabel = `Audio Source - Oscillator [${this.tag}]`;
                osc.type = type === 'saw' ? 'sawtooth' : type;
                osc.frequency.setValueAtTime(frequency, t);
                const gain = ctx.createGain();
                gain._debugLabel = `Audio Source - Oscillator Gain [${this.tag}]`;
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
                console.log(`Playing oscillator: type=${type}, freq=${frequency}, duration=${duration}`);
                osc.connect(gain).connect(this.outNode);
                console.log('Oscillator connected to output node');
                osc.start(t);
                osc.stop(t + duration);
            }

            playCustomBuffer(rate = 1) {
                const ctx = this.app.audioCtx;
                if (!ctx || !this.customBuffer) return;
                const t = ctx.currentTime;
                const src = ctx.createBufferSource();
                src.buffer = this.customBuffer;
                src.playbackRate.setValueAtTime(rate, t);
                src.connect(this.outNode);
                src.start(t);
            }

            loadCustomSample(file) {
                if (!this.app.audioCtx) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.app.audioCtx.decodeAudioData(e.target.result, (buffer) => {
                        this.customBuffer = buffer;
                        this.basePlaybackRate = 1;
                        this.trigger('custom');
                    }, (e) => console.error("Error decoding audio data", e));
                };
                reader.readAsArrayBuffer(file);
            }

            async toggleMic() {
                if (!this.app) return;
                await this.app.startAudio();
                if (this.micPending) return;
                this.micPending = true;
                try {
                    if (this.micActive) {
                        this.stopMic();
                        return;
                    }
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        this.micError = new Error('Microphone unavailable');
                        console.error('Microphone unavailable in this browser');
                        return;
                    }
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const ctx = this.app.audioCtx;
                    if (!ctx) {
                        stream.getTracks().forEach(track => track.stop());
                        this.micError = new Error('Audio context unavailable');
                        return;
                    }
                    this.micStream = stream;
                    this.micSource = ctx.createMediaStreamSource(stream);
                    this.micSource.connect(this.outNode);
                    this.micActive = true;
                    this.micError = null;
                } catch (err) {
                    this.micError = err;
                    this.stopMic();
                    console.error('Microphone access failed', err);
                } finally {
                    this.micPending = false;
                }
            }

            stopMic() {
                if (this.micSource) {
                    try { this.micSource.disconnect(); } catch (e) { }
                    this.micSource = null;
                }
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => {
                        try { track.stop(); } catch (e) { }
                    });
                    this.micStream = null;
                }
                this.micActive = false;
            }

            trigger(type) {
                if (!this.app.audioCtx) return;

                this.lastType = type;
                this.app.lastAudioSourceNode = this; // Register as active for spacebar

                const ctx = this.app.audioCtx;
                const t = ctx.currentTime;
                const out = this.outNode;

                if (type === 'custom' && this.customBuffer) {
                    this.basePlaybackRate = 1;
                    this.playCustomBuffer(1);
                } else if (type === 'kick') {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    osc.connect(gain);
                    gain.connect(out);
                    osc.start(t); osc.stop(t + 0.5);
                } else if (type === 'snare') {
                    const noise = ctx.createBufferSource();
                    noise.buffer = AudioUtils.createNoise(0.2);
                    const nGain = ctx.createGain();
                    const nFilter = ctx.createBiquadFilter();
                    nFilter.type = 'highpass'; nFilter.frequency.value = 1000;
                    nGain.gain.setValueAtTime(1, t); nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    noise.connect(nFilter).connect(nGain).connect(out);
                    noise.start(t);

                    const osc = ctx.createOscillator();
                    const oGain = ctx.createGain();
                    osc.frequency.setValueAtTime(250, t); osc.frequency.linearRampToValueAtTime(100, t + 0.1);
                    oGain.gain.setValueAtTime(0.5, t); oGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.connect(oGain).connect(out);
                    osc.start(t); osc.stop(t + 0.2);
                } else if (type === 'hh') {
                    const noise = ctx.createBufferSource();
                    noise.buffer = AudioUtils.createNoise(0.05);
                    const nGain = ctx.createGain();
                    const nFilter = ctx.createBiquadFilter();
                    nFilter.type = 'highpass'; nFilter.frequency.value = 5000;
                    nGain.gain.setValueAtTime(0.6, t); nGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                    noise.connect(nFilter).connect(nGain).connect(out);
                    noise.start(t);
                } else if (type === 'sine' || type === 'saw' || type === 'square' || type === 'triangle') {
                    this.baseFrequency = 440;
                    this.playOscillator(type, this.baseFrequency);
                } else if (type === 'noise') {
                    const buffer = AudioUtils.createNoise(0.4);
                    if (buffer) {
                        const noise = ctx.createBufferSource();
                        noise.buffer = buffer;
                        const gain = ctx.createGain();
                        gain.gain.setValueAtTime(0.4, t);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
                        noise.connect(gain).connect(out);
                        noise.start(t);
                    }
                } else if (type === 'mic') {
                    this.toggleMic();
                }
            }

            triggerNote(semitone, octaveOffset = 0) {
                if (!this.app.audioCtx) return;
                if (!this.isPitchable()) return;
                const ratio = Math.pow(2, octaveOffset) * Math.pow(2, semitone / 12);

                if (this.lastType === 'custom') {
                    this.playCustomBuffer(this.basePlaybackRate * ratio);
                } else if (this.lastType === 'sine' || this.lastType === 'saw' || this.lastType === 'square' || this.lastType === 'triangle') {
                    this.playOscillator(this.lastType, this.baseFrequency * ratio);
                }

                this.app.lastAudioSourceNode = this;
            }

            onRemoved() {
                this.stopMic();
            }
        }

        class GainNodeUI extends DSPNode {
            constructor(x, y, app) { super(x, y, 'Gain', app); this.type = 'gain'; }
            initAudio(ctx) {
                this.tag = Math.random().toString(36).slice(2, 6);

                this.inputNode = ctx.createGain();
                this.inputNode._debugLabel = `Gain In [${this.tag}]`;
                this.outputNode = ctx.createGain();
                this.outputNode._debugLabel = `Gain Out [${this.tag}]`;
                this.inputNode.connect(this.outputNode);

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputNode }];

                this.params = [{
                    label: 'Level', type: 'range', value: 1.0, min: 0, max: 2, scale: 'linear',
                    onChange: (v) => this.outputNode.gain.setTargetAtTime(v, ctx.currentTime, 0.01)
                }];
                this.initializeParams();
                this.computeHeight();
            }

            onRemoved() {
                try {
                    this.inputNode.disconnect();
                } catch (e) { }
                try {
                    this.outputNode.disconnect();
                } catch (e) { }
            }

        }

        class MixerNodeUI extends DSPNode {
            constructor(x, y, app) { super(x, y, 'Mixer (4ch)', app); this.type = 'mixer'; this.width = 160; }
            initAudio(ctx) {
                this.outNode = ctx.createGain();
                this.gains = [];
                this.inputs = [];

                for (let i = 0; i < 4; i++) {
                    const g = ctx.createGain();
                    g.connect(this.outNode);
                    this.gains.push(g);
                    this.inputs.push({ name: `In ${i + 1}`, id: i, node: g });
                }

                this.outputs = [{ name: 'Mix Out', id: 0, node: this.outNode }];

                this.params = this.gains.map((g, i) => ({
                    label: `Ch ${i + 1} Vol`, type: 'range', value: 0.8, min: 0, max: 1, scale: 'linear',
                    onChange: (v) => g.gain.setTargetAtTime(v, ctx.currentTime, 0.01)
                }));
                this.initializeParams();
                this.computeHeight();
            }
        }

        class WetDryNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Wet/Dry', app);
                this.type = 'wetdry';
                this.width = 160;
                this.blendValue = 0.5;
                this.levelValue = 1;
            }

            initAudio(ctx) {
                this.dryGain = ctx.createGain();
                this.wetGain = ctx.createGain();
                this.outputGain = ctx.createGain();

                this.dryGain.connect(this.outputGain);
                this.wetGain.connect(this.outputGain);

                this.inputs = [
                    { name: 'Dry In', id: 0, node: this.dryGain },
                    { name: 'Wet In', id: 1, node: this.wetGain }
                ];
                this.outputs = [{ name: 'Mix Out', id: 0, node: this.outputGain }];

                this.params = [
                    {
                        label: 'Wet/Dry', type: 'range', value: this.blendValue, min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setBlend(v)
                    },
                    {
                        label: 'Level', type: 'range', value: this.levelValue, min: 0, max: 2, scale: 'linear',
                        onChange: (v) => this.setLevel(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();
                this.refreshGains(ctx);
            }

            setBlend(v) {
                this.blendValue = v;
                this.refreshGains();
            }

            setLevel(v, ctx) {
                this.levelValue = v;
                if (this.outputGain && ctx) {
                    this.outputGain.gain.setTargetAtTime(v, ctx.currentTime, 0.01);
                }
            }

            refreshGains(ctxOverride) {
                const ctx = ctxOverride || (this.app ? this.app.audioCtx : null);
                if (!ctx) return;
                const now = ctx.currentTime;
                const angle = this.blendValue * Math.PI * 0.5;
                // Use constant-power law to keep perceived loudness even across the blend.
                const dry = Math.cos(angle);
                const wet = Math.sin(angle);

                if (this.dryGain) {
                    this.dryGain.gain.setTargetAtTime(dry, now, 0.01);
                }
                if (this.wetGain) {
                    this.wetGain.gain.setTargetAtTime(wet, now, 0.01);
                }
                if (this.outputGain) {
                    this.outputGain.gain.setTargetAtTime(this.levelValue, now, 0.01);
                }
            }
        }

        class PannerNodeUI extends DSPNode {
            constructor(x, y, app) { super(x, y, 'Stereo Panner', app); this.type = 'panner'; }
            initAudio(ctx) {
                this.node = ctx.createStereoPanner();
                this.inputs = [{ name: 'In', id: 0, node: this.node }];
                this.outputs = [{ name: 'Out', id: 0, node: this.node }];
                this.params = [{
                    label: 'Pan', type: 'range', value: 0, min: -1, max: 1, scale: 'linear',
                    onChange: (v) => this.node.pan.setTargetAtTime(v, ctx.currentTime, 0.01)
                }];
                this.initializeParams();
                this.computeHeight();
            }
        }

        class DelayNodeUI extends DSPNode {
            constructor(x, y, app) { super(x, y, 'Delay', app); this.type = 'delay'; }
            initAudio(ctx) {
                this.node = ctx.createDelay(5.0);
                this.node.delayTime.value = 0.5;
                this.inputs = [{ name: 'In', id: 0, node: this.node }];
                this.outputs = [{ name: 'Out', id: 0, node: this.node }];
                this.params = [{
                    label: 'Time (s)', type: 'range', value: 0.5, min: 0.01, max: 2, scale: 'log',
                    onChange: (v) => this.node.delayTime.setTargetAtTime(v, ctx.currentTime, 0.02)
                }];
                this.initializeParams();
                this.computeHeight();
            }
            onRemoved() {
                try {
                    this.node.disconnect();
                } catch (e) { }
            }
        }

        class BiquadNodeUI extends DSPNode {
            constructor(x, y, app, type) {
                const titleMap = {
                    lowpass: 'LP Filter',
                    highpass: 'HP Filter',
                    bandpass: 'BP Filter',
                    notch: 'Notch Filter',
                    allpass: 'Allpass (Biquad)'
                };
                const typeMap = {
                    lowpass: 'lpf',
                    highpass: 'hpf',
                    bandpass: 'bpf',
                    notch: 'notch',
                    allpass: 'allpass'
                };
                super(x, y, titleMap[type] || 'Filter', app);
                this.filterType = type;
                this.type = typeMap[type] || 'filter';
            }
            initAudio(ctx) {
                this.node = ctx.createBiquadFilter();
                this.node.type = this.filterType;
                let defaultFreq = 1000;
                if (this.filterType === 'lowpass') defaultFreq = 2000;
                else if (this.filterType === 'highpass') defaultFreq = 500;
                this.node.frequency.value = defaultFreq;
                if (this.filterType === 'notch' || this.filterType === 'bandpass') {
                    this.node.Q.value = 1;
                }
                if (this.filterType === 'allpass') {
                    this.node.Q.value = 0.707;
                }

                this.inputs = [{ name: 'In', id: 0, node: this.node }];
                this.outputs = [{ name: 'Out', id: 0, node: this.node }];

                this.params = [{
                    label: 'Freq (Hz)', type: 'range', value: this.node.frequency.value, min: 20, max: 15000, scale: 'log',
                    onChange: (v) => this.node.frequency.setTargetAtTime(v, ctx.currentTime, 0.02)
                },
                {
                    label: 'Q', type: 'range', value: this.node.Q.value || 1, min: -3, max: 20, scale: 'linear',
                    onChange: (v) => this.node.Q.setTargetAtTime(v, ctx.currentTime, 0.02)
                }];
                this.initializeParams();
                this.computeHeight();
            }
        }

        class FDNNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'FDN (8-Tap Householder)', app);
                this.type = 'fdn-scalable';
                this.width = 180;
                this.N = 8; // 8 Taps

                this.delays = [];
                this.feedbackGains = [];
                this.dampers = [];
                this.lfos = [];
                this.lfoGains = [];

                const sampleRate = 48000;

                this.baseDelays = [
                    571 / sampleRate,
                    779 / sampleRate,
                    903 / sampleRate,
                    1127 / sampleRate,
                    1349 / sampleRate,
                    1491 / sampleRate,
                    1557 / sampleRate,
                    1617 / sampleRate
                ];

                // LFO Tuning Offsets (in Hz) for Modulation Diversity
                this.lfoTuningOffsets = [0, 0.01, 0.0142, 0.02, 0.025, 0.028235, 0.03151, 0.0343341];

                this.currentSize = 1.0;
                this.currentDecay = 2.0;
                this.modRateBase = 0.1;
                this.modRateSpread = 0.05;
                this.modAmount = 0.5;
            }

            initAudio(ctx) {
                // --- 1. Master I/O ---
                this.inputGain = ctx.createGain();
                this.outputMixer = ctx.createGain();

                // --- 2. Householder Matrix Node ---
                // Formula: Output = Input - (2/N * Sum)
                this.matrixSum = ctx.createGain();

                // CRITICAL FIX: Dynamic scaling based on N. 
                // For N=8, this becomes -0.25. For N=4, it was -0.5.
                const scalingFactor = -2.0 / this.N;
                this.matrixSum.gain.value = scalingFactor;

                // Cleanup
                this.delays = [];
                this.feedbackGains = [];
                this.dampers = [];
                this.lfos = [];
                this.lfoGains = [];

                // --- 3. Construct the Feedback Loops ---
                for (let i = 0; i < this.N; i++) {
                    // A. Delay Line
                    const delay = ctx.createDelay(1.5); // More headroom for size > 1.0
                    delay.delayTime.value = this.baseDelays[i] * this.currentSize;
                    this.delays.push(delay);

                    // B. Modulation
                    const lfo = ctx.createOscillator();
                    const freq = Math.max(0.01, this.modRateBase + (i * this.modRateSpread) + this.lfoTuningOffsets[i]);
                    lfo.frequency.value = freq;
                    lfo.phase = Math.random() * Math.PI * 2; // Random start phase
                    const lfoGain = ctx.createGain();
                    const depth = Math.max(0, this.modAmount) * 0.001;
                    lfoGain.gain.value = depth;

                    lfo.connect(lfoGain).connect(delay.delayTime);
                    lfo.start();
                    this.lfos.push(lfo);
                    this.lfoGains.push(lfoGain);

                    // C. Feedback Gain
                    const fbGain = ctx.createGain();
                    fbGain.gain.value = 0.5;
                    this.feedbackGains.push(fbGain);

                    // D. Color / Stability Filters

                    // 1. Highpass (DC Blocker)
                    const hpf = ctx.createBiquadFilter();
                    hpf.type = 'highpass';
                    hpf.frequency.value = 20;
                    hpf.Q.value = -3; // Standard Butterworth-ish response

                    // 2. Lowpass (Damping)
                    // STABILITY FIX: Q=0 is physically accurate (1-pole). 
                    // Q=-3 is a hack that isn't needed with correct matrix scaling.
                    const lpf = ctx.createBiquadFilter();
                    lpf.type = 'lowpass';
                    lpf.frequency.value = 15000;
                    lpf.Q.value = -3;
                    this.dampers.push(lpf);

                    // --- WIRING ---

                    // 1. Forward Path: Delay -> Gain -> HPF -> LPF
                    delay.connect(fbGain);
                    fbGain.connect(hpf);
                    hpf.connect(lpf);

                    // 2. Matrix Injection (Send to Summer)
                    lpf.connect(this.matrixSum);

                    // 3. Feedback Return (Householder)
                    // Input = Self + (Sum * -2/N)
                    lpf.connect(delay);
                    this.matrixSum.connect(delay);

                    // 4. Output Tap
                    delay.connect(this.outputMixer);
                }

                // Connect Input
                this.delays.forEach(d => this.inputGain.connect(d));

                // --- 4. Parameters ---
                this.inputs = [{ name: 'In', id: 0, node: this.inputGain }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputMixer }];

                this.params = [
                    {
                        label: 'Size (Scale)', type: 'range', value: 1.0, min: 0.1, max: 2.0, scale: 'linear',
                        onChange: (v) => this.setSize(v, ctx)
                    },
                    {
                        label: 'Decay (s)', type: 'range', value: 2.0, min: 0.1, max: 10.0, scale: 'log',
                        onChange: (v) => this.setDecayTime(v, ctx)
                    },
                    {
                        label: 'Damping', type: 'range', value: 8000, min: 500, max: 20000, scale: 'log',
                        onChange: (v) => this.setDamping(v, ctx)
                    },
                    {
                        label: 'Mod Rate', type: 'range', value: this.modRateBase, min: 0.01, max: 5.0, scale: 'log',
                        onChange: (v) => this.setModulationRate(v, ctx)
                    },
                    {
                        label: 'Mod Amt', type: 'range', value: this.modAmount, min: 0, max: 4.0, scale: 'linear',
                        onChange: (v) => this.setModulationAmount(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();

                // Initial setup
                this.setSize(1.0, ctx);
                this.setModulationRate(this.modRateBase, ctx);
                this.setModulationAmount(this.modAmount, ctx);
            }

            setSize(scale, ctx) {
                this.currentSize = Math.max(0.01, scale);
                this.delays.forEach((d, i) => {
                    const newTime = this.baseDelays[i] * this.currentSize;
                    // Limit max delay time to prevent errors
                    if (newTime < 4.0) d.delayTime.setTargetAtTime(newTime, ctx.currentTime, 0.05);
                });
                this.setDecayTime(this.currentDecay, ctx);
            }

            setDecayTime(seconds, ctx) {
                this.currentDecay = Math.max(0.01, seconds);

                // 1. Calculate REAL average delay
                // We sum the actual base delays to get a precise average.
                const sumBase = this.baseDelays.reduce((a, b) => a + b, 0);
                const baseAvg = sumBase / this.N;
                const currentAvgTau = baseAvg * this.currentSize;

                // 2. T60 Formula
                let g = Math.pow(10, (-3 * currentAvgTau) / this.currentDecay);

                // 3. Stability Cap
                // 0.997 is the industry standard safety margin for feedback loops.
                g = Math.min(0.997, g);

                this.feedbackGains.forEach(gn => gn.gain.setTargetAtTime(g, ctx.currentTime, 0.02));
            }

            setDamping(freq, ctx) {
                this.dampers.forEach(lpf => lpf.frequency.setTargetAtTime(freq, ctx.currentTime, 0.02));
            }

            setModulationRate(baseRate, ctx) {
                this.modRateBase = Math.max(0.01, baseRate);
                const now = ctx.currentTime;
                this.lfos.forEach((osc, idx) => {
                    const freq = Math.max(0.01, this.modRateBase + (idx * this.modRateSpread) + this.lfoTuningOffsets[idx]);
                    osc.frequency.setTargetAtTime(freq, now, 0.02);
                });
            }

            setModulationAmount(amount, ctx) {
                this.modAmount = Math.max(0, amount);
                const depth = this.modAmount * 0.001;
                const now = ctx.currentTime;
                this.lfoGains.forEach(gn => gn.gain.setTargetAtTime(depth, now, 0.02));
            }
        }

        class PitchShiftNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Pitch Shifter', app);
                this.type = 'pitch-shifter';
                this.width = 200;

                this.semitones = 0;
                this.cents = 0;
                this.mix = 1;
                this.pitchRatio = 1;

                this.context = null;
                this.inputGain = null;
                this.outputGain = null;
                this.dryDelay = null;
                this.dryGain = null;
                this.wetGain = null;
                this.bypassGain = null;
                this.workletNode = null;
                this.deferredInit = false;
                this.latencySamples = 0;
                this._bypassCleanupTimer = null;

                this.fftSize = PitchShiftNodeUI.defaultFFTSize;
                this.overlap = PitchShiftNodeUI.defaultOverlap;
            }

            initAudio(ctx) {
                this.context = ctx;

                this.inputGain = ctx.createGain();
                this.outputGain = ctx.createGain();
                this.dryDelay = ctx.createDelay(1.0);
                this.dryGain = ctx.createGain();
                this.wetGain = ctx.createGain();
                this.bypassGain = ctx.createGain();
                this.bypassGain.gain.value = 1;

                this.inputGain.connect(this.dryDelay);
                this.dryDelay.connect(this.dryGain);
                this.dryGain.connect(this.outputGain);

                this.inputGain.connect(this.bypassGain);
                this.bypassGain.connect(this.wetGain);
                this.wetGain.connect(this.outputGain);

                this.inputs = [{ name: 'In', id: 0, node: this.inputGain }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];

                this.params = [
                    {
                        label: 'Semitones',
                        type: 'range',
                        value: this.semitones,
                        min: -24,
                        max: 24,
                        scale: 'linear',
                        onChange: (v) => this.setSemitones(v, ctx)
                    },
                    {
                        label: 'Fine (cents)',
                        type: 'range',
                        value: this.cents,
                        min: -100,
                        max: 100,
                        scale: 'linear',
                        onChange: (v) => this.setFine(v, ctx)
                    },
                    {
                        label: 'Mix',
                        type: 'range',
                        value: this.mix,
                        min: 0,
                        max: 1,
                        scale: 'linear',
                        onChange: (v) => this.setMix(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();

                this.latencySamples = this.estimateLatency(this.fftSize, this.overlap);
                this.updateDryDelay(ctx);
                this.updateMix(ctx);

                this.prepareWorklet(ctx);
            }

            estimateLatency(fftSize, overlap) {
                const slices = Math.max(2, Math.floor(overlap));
                const hop = Math.max(1, Math.floor(fftSize / slices));
                return Math.max(0, fftSize - hop);
            }

            setSemitones(value, ctx) {
                this.semitones = typeof value === 'number' ? value : 0;
                this.updatePitchParam(ctx);
            }

            setFine(value, ctx) {
                this.cents = typeof value === 'number' ? value : 0;
                this.updatePitchParam(ctx);
            }

            setMix(value, ctx) {
                this.mix = Math.max(0, Math.min(1, value));
                this.updateMix(ctx);
            }

            updateMix(ctx) {
                if (!this.dryGain || !this.wetGain) return;
                const context = ctx || this.context;
                if (context) {
                    const now = context.currentTime;
                    this.dryGain.gain.setTargetAtTime(1 - this.mix, now, 0.02);
                    this.wetGain.gain.setTargetAtTime(this.mix, now, 0.02);
                } else {
                    this.dryGain.gain.value = 1 - this.mix;
                    this.wetGain.gain.value = this.mix;
                }
            }

            computePitchRatio() {
                const total = this.semitones + (this.cents / 100);
                const ratio = Math.pow(2, total / 12);
                return Math.min(4, Math.max(0.25, ratio));
            }

            updatePitchParam(ctx) {
                this.pitchRatio = this.computePitchRatio();
                const context = ctx || this.context;
                if (this.workletNode) {
                    const param = this.workletNode.parameters.get('ratio');
                    if (param) {
                        if (context) {
                            param.setTargetAtTime(this.pitchRatio, context.currentTime, 0.01);
                        } else {
                            param.value = this.pitchRatio;
                        }
                    }
                }
            }

            updateDryDelay(ctx) {
                if (!this.dryDelay) return;
                const context = ctx || this.context;
                if (!context) return;
                const seconds = Math.min(0.9, Math.max(0, this.latencySamples / context.sampleRate));
                this.dryDelay.delayTime.setTargetAtTime(seconds, context.currentTime, 0.02);
            }

            prepareWorklet(ctx) {
                if (!PitchShiftNodeUI.shouldUseWorklet(ctx)) {
                    console.warn('Pitch shifter worklet unavailable; wet signal will remain bypassed.');
                    return;
                }

                const attachIfReady = () => {
                    if (this.audioCtxActive(ctx) && !this.workletNode) {
                        this.attachWorklet(ctx);
                    }
                };

                if (PitchShiftNodeUI.isWorkletReady(ctx)) {
                    attachIfReady();
                    return;
                }

                this.deferredInit = true;
                PitchShiftNodeUI.ensureWorklet(ctx)
                    .then(() => {
                        this.deferredInit = false;
                        attachIfReady();
                    })
                    .catch((err) => {
                        this.deferredInit = false;
                        PitchShiftNodeUI.markUnsupported(ctx);
                        console.error('Pitch shifter worklet load failed', err);
                    });
            }

            audioCtxActive(ctx) {
                return !!this.context && this.context === ctx;
            }

            attachWorklet(ctx) {
                try {
                    this.workletNode = new AudioWorkletNode(ctx, 'hq-pitch-shifter', {
                        numberOfInputs: 1,
                        numberOfOutputs: 1,
                        outputChannelCount: [2],
                        channelCount: 2,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'speakers',
                        parameterData: { ratio: this.pitchRatio },
                        processorOptions: {
                            fftSize: this.fftSize,
                            overlap: this.overlap
                        }
                    });
                } catch (err) {
                    console.error('Pitch shifter worklet initialisation failed', err);
                    this.workletNode = null;
                    return;
                }

                this.inputGain.connect(this.workletNode);
                this.workletNode.connect(this.wetGain);

                if (this.bypassGain) {
                    const fadeEnd = ctx.currentTime + 0.05;
                    this.bypassGain.gain.setValueAtTime(this.bypassGain.gain.value, ctx.currentTime);
                    this.bypassGain.gain.linearRampToValueAtTime(0, fadeEnd);
                    if (this._bypassCleanupTimer) {
                        clearTimeout(this._bypassCleanupTimer);
                    }
                    this._bypassCleanupTimer = setTimeout(() => {
                        if (!this.audioCtxActive(ctx) || !this.bypassGain) return;
                        try { this.inputGain.disconnect(this.bypassGain); } catch (e) { }
                        try { this.bypassGain.disconnect(); } catch (e) { }
                        this.bypassGain = null;
                    }, 80);
                }

                this.updatePitchParam(ctx);
                this.sendConfiguration();

                this.workletNode.port.onmessage = (event) => {
                    this.handleWorkletMessage(event.data);
                };
            }

            sendConfiguration() {
                if (!this.workletNode) return;
                this.workletNode.port.postMessage({
                    type: 'configure',
                    fftSize: this.fftSize,
                    overlap: this.overlap
                });
            }

            handleWorkletMessage(data) {
                if (!data || typeof data !== 'object') return;
                if (data.type === 'latency') {
                    const samples = Number(data.samples);
                    if (Number.isFinite(samples)) {
                        this.latencySamples = samples;
                        this.updateDryDelay();
                    }
                }
            }

            onRemoved() {
                if (this._bypassCleanupTimer) {
                    clearTimeout(this._bypassCleanupTimer);
                    this._bypassCleanupTimer = null;
                }

                this.deferredInit = false;

                if (this.workletNode) {
                    try { this.workletNode.port.postMessage({ type: 'reset' }); } catch (e) { }
                    try { this.workletNode.port.onmessage = null; } catch (e) { }
                    try { this.workletNode.disconnect(); } catch (e) { }
                }
                this.workletNode = null;

                if (this.bypassGain) {
                    try { this.bypassGain.disconnect(); } catch (e) { }
                    this.bypassGain = null;
                }

                if (this.inputGain) {
                    try { this.inputGain.disconnect(); } catch (e) { }
                }
                if (this.dryDelay) {
                    try { this.dryDelay.disconnect(); } catch (e) { }
                }
                if (this.dryGain) {
                    try { this.dryGain.disconnect(); } catch (e) { }
                }
                if (this.wetGain) {
                    try { this.wetGain.disconnect(); } catch (e) { }
                }
                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                }

                this.inputGain = null;
                this.outputGain = null;
                this.dryDelay = null;
                this.dryGain = null;
                this.wetGain = null;
                this.context = null;
            }
        }

        PitchShiftNodeUI.defaultFFTSize = 2048;
        PitchShiftNodeUI.defaultOverlap = 4;
        PitchShiftNodeUI.workletModulePath = 'worklets/hq-pitch-shifter.js';

        PitchShiftNodeUI.shouldUseWorklet = function (ctx) {
            if (!ctx) return false;
            if (PitchShiftNodeUI.isWorkletUnsupported(ctx)) return false;
            if (!ctx.audioWorklet) return false;
            if (typeof AudioWorkletNode === 'undefined') return false;
            if (typeof window !== 'undefined') {
                const protocol = window.location && window.location.protocol ? window.location.protocol.toLowerCase() : '';
                if (protocol && protocol !== 'http:' && protocol !== 'https:') return false;
                if (typeof window.isSecureContext !== 'undefined' && window.isSecureContext === false) return false;
            }
            return true;
        };

        PitchShiftNodeUI.markUnsupported = function (ctx) {
            if (!ctx) return;
            if (!PitchShiftNodeUI._workletStates) {
                PitchShiftNodeUI._workletStates = new WeakMap();
            }
            PitchShiftNodeUI._workletStates.set(ctx, { ready: false, unsupported: true });
        };

        PitchShiftNodeUI.ensureWorklet = function (ctx) {
            if (!ctx) return Promise.resolve();

            if (!PitchShiftNodeUI._workletStates) {
                PitchShiftNodeUI._workletStates = new WeakMap();
            }

            const state = PitchShiftNodeUI._workletStates.get(ctx);
            if (state && state.ready) {
                return Promise.resolve();
            }
            if (state && state.promise) {
                return state.promise;
            }

            if (!PitchShiftNodeUI.shouldUseWorklet(ctx)) {
                PitchShiftNodeUI.markUnsupported(ctx);
                return Promise.resolve();
            }

            const modulePath = PitchShiftNodeUI.workletModulePath;
            if (!modulePath) {
                PitchShiftNodeUI.markUnsupported(ctx);
                return Promise.resolve();
            }

            const promise = ctx.audioWorklet.addModule(modulePath)
                .then(() => {
                    PitchShiftNodeUI._workletStates.set(ctx, { ready: true });
                })
                .catch((err) => {
                    PitchShiftNodeUI.markUnsupported(ctx);
                    throw err;
                });

            PitchShiftNodeUI._workletStates.set(ctx, { ready: false, promise });
            return promise;
        };

        PitchShiftNodeUI.isWorkletReady = function (ctx) {
            if (!ctx || !PitchShiftNodeUI._workletStates) return false;
            const state = PitchShiftNodeUI._workletStates.get(ctx);
            return !!(state && state.ready);
        };

        PitchShiftNodeUI.isWorkletUnsupported = function (ctx) {
            if (!ctx || !PitchShiftNodeUI._workletStates) return false;
            const state = PitchShiftNodeUI._workletStates.get(ctx);
            return !!(state && state.unsupported);
        };


        class DiffuserNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Diffuser (Smear)', app);
                this.type = 'diffuser';
                this.filterChain = [];
                this.width = 160;
                this.baseFrequencies = [500, 1200, 2500, 4000];
                this.modOscillators = [];
                this.modGains = [];
                this.modDepthValue = 0;
                this.modRateValue = 0.35;
                this.modRateSpread = 0.05;
                this.lfoTuningOffsets = [0, 0.01956954, 0.0142, 0.022352, 0.025535];
            }

            initAudio(ctx) {
                this.cleanupModulation();
                // --- 1. Create Input and Output Gains ---
                this.inputGain = ctx.createGain();
                this.outputGain = ctx.createGain();

                // --- 2. Define Allpass Filter Parameters ---
                // These short, non-harmonic delay times prevent metallic ringing.
                // We simulate a series of first-order APFs by staggering the Biquad center frequencies.
                // This is the default Q value, controlling the amount of phase shift.
                const defaultQ = 2.0;

                // --- 3. Build the Internal Filter Chain (Cascade) ---
                let previousNode = this.inputGain;
                this.filterChain = [];
                this.modOscillators = [];
                this.modGains = [];
                this.baseFrequencies.forEach((freq, index) => {
                    const ap = ctx.createBiquadFilter();
                    ap.type = 'allpass';
                    ap.frequency.value = freq;
                    ap.Q.value = defaultQ;

                    const modGain = ctx.createGain();
                    modGain.gain.value = 0;
                    this.modGains.push(modGain);

                    const lfo = ctx.createOscillator();
                    lfo.type = 'sine';
                    lfo.frequency.value = Math.max(0.01, this.modRateValue + (index * this.modRateSpread) + this.lfoTuningOffsets[index]);
                    lfo.phase = Math.random() * Math.PI * 2;
                    lfo.connect(modGain);
                    modGain.connect(ap.frequency);
                    lfo.start();
                    this.modOscillators.push(lfo);

                    // Connect the previous node to this new allpass filter
                    previousNode.connect(ap);
                    previousNode = ap;
                    this.filterChain.push(ap);
                });

                // --- 4. Connect the last filter to the output gain ---
                previousNode.connect(this.outputGain);

                // --- 5. Define I/O Ports ---
                this.inputs = [{ name: 'In', id: 0, node: this.inputGain }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];

                // --- 6. Define User Parameters ---
                this.params = [
                    {
                        label: 'Smear Q',
                        type: 'range',
                        value: defaultQ,
                        min: 0.1,
                        max: 10,
                        scale: 'linear',
                        // When the user changes the Q slider, update ALL internal filters
                        onChange: (v) => {
                            this.filterChain.forEach(ap => ap.Q.setTargetAtTime(v, ctx.currentTime, 0.01));
                        }
                    },
                    {
                        label: 'Mod Depth',
                        type: 'range',
                        value: this.modDepthValue,
                        min: 0,
                        max: 1,
                        scale: 'linear',
                        onChange: (v) => this.setModDepth(v, ctx)
                    },
                    {
                        label: 'Mod Rate',
                        type: 'range',
                        value: this.modRateValue,
                        min: 0.01,
                        max: 20,
                        scale: 'log',
                        onChange: (v) => this.setModRate(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();
                this.setModDepth(this.modDepthValue, ctx);
                this.setModRate(this.modRateValue, ctx);
            }

            setModDepth(value, ctx) {
                this.modDepthValue = Math.max(0, value);
                const context = ctx || (this.app && this.app.audioCtx);
                if (!context) return;
                const now = context.currentTime;
                const maxRatio = 0.4;
                this.modGains.forEach((gain, idx) => {
                    const base = this.baseFrequencies[idx] || 0;
                    const depthHz = base * maxRatio * this.modDepthValue;
                    gain.gain.setTargetAtTime(depthHz, now, 0.05);
                });
            }

            setModRate(value, ctx) {
                this.modRateValue = Math.max(0.01, value);
                const context = ctx || (this.app && this.app.audioCtx);
                if (!context) return;
                const now = context.currentTime;
                this.modOscillators.forEach((osc, idx) => {
                    const freq = Math.max(0.01, this.modRateValue + (idx * this.modRateSpread) + this.lfoTuningOffsets[idx]);
                    osc.frequency.setTargetAtTime(freq, now, 0.05);
                });
            }

            cleanupModulation() {
                if (this.modOscillators) {
                    this.modOscillators.forEach(osc => {
                        try { osc.stop(); } catch (e) { }
                        try { osc.disconnect(); } catch (e) { }
                    });
                }
                if (this.modGains) {
                    this.modGains.forEach(gain => {
                        try { gain.disconnect(); } catch (e) { }
                    });
                }
                this.modOscillators = [];
                this.modGains = [];
            }

            onRemoved() {
                this.cleanupModulation();
            }
        }

        class CombNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Comb (FB)', app);
                this.type = 'comb';
            }

            initAudio(ctx) {
                this.inputGain = ctx.createGain();
                this.output = ctx.createGain();

                // The Loop Components
                this.delay = ctx.createDelay(1.0); // Max 1 second
                this.feedbackGain = ctx.createGain();
                this.dampFilter = ctx.createBiquadFilter();

                this.dampFilter.type = 'lowpass';
                this.dampFilter.Q.value = -3.0;
                this.dampFilter.frequency.value = 6000; // Default "Open" frequency

                // 2. Delay defaults
                this.delay.delayTime.value = 0.04;

                // 3. Initial Gain
                this.feedbackGain.gain.value = 0.7;

                // --- Topology: Input -> Delay -> Filter -> Feedback -> Delay ---

                // Signal enters
                this.inputGain.connect(this.delay);

                this.delay.connect(this.output);

                // Feedback Loop
                this.delay.connect(this.dampFilter);
                this.dampFilter.connect(this.feedbackGain);
                this.feedbackGain.connect(this.delay);

                // --- IO Setup ---
                this.inputs = [{ name: 'In', id: 0, node: this.inputGain }];
                this.outputs = [{ name: 'Out', id: 0, node: this.output }];

                // --- Parameters ---
                this.params = [
                    {
                        label: 'Delay (ms)', type: 'range', value: 40, min: 1, max: 100, scale: 'linear',
                        onChange: (v) => this.setDelayTime(v, ctx)
                    },
                    {
                        label: 'Feedback', type: 'range', value: 0.5, min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setFeedback(v, ctx)
                    },
                    {
                        label: 'Damp', type: 'range', value: 0.5, min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setDamp(v, ctx)
                    }
                ];

                // Allow your presets to modulate damp/feedback
                this.params[1].modulationStrategy = 'override';
                this.params[2].modulationStrategy = 'override';

                // Initialize
                this.initializeParams();
                this.computeHeight();
            }

            setDelayTime(v, ctx) {
                // Smooth transition to prevent zipper noise
                this.delay.delayTime.setTargetAtTime(v / 1000, ctx.currentTime, 0.02);
            }

            setFeedback(v, ctx) {
                const min = 0;
                const max = 1;
                const scaledGain = min + (v * (max - min));

                this.feedbackGain.gain.setTargetAtTime(scaledGain, ctx.currentTime, 0.02);
            }

            setDamp(v, ctx) {
                // Damp = 0 -> Filter Open.
                // Damp = 1 -> Filter Closed.

                const minFreq = 100;
                const maxFreq = 20000;

                // Logarithmic mapping acts more like the linear coefficient of the original algorithm
                // Damp 0 = maxFreq, Damp 1 = minFreq
                const frequency = minFreq * Math.pow(maxFreq / minFreq, 1 - v);

                this.dampFilter.frequency.setTargetAtTime(frequency, ctx.currentTime, 0.02);
            }
        }

        class AllpassNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Allpass (Delay)', app);
                this.type = 'allpass-delay';
                this.defaultDelayMs = 50;
                this.defaultGain = 0.5;
                this.maxDelayMs = 150;
                this.delayMsValue = this.defaultDelayMs;
                this.gainValue = this.defaultGain;
                this.workletNode = null;
                this.context = null;
                this.tag = Math.random().toString(36).slice(2, 6);
            }

            initAudio(ctx) {
                this.context = ctx;
                this.inputNode = ctx.createGain();
                this.inputNode._debugLabel = `Allpass In [${this.tag}]`;
                this.outputNode = ctx.createGain();
                this.outputNode._debugLabel = `Allpass Out [${this.tag}]`;
                this.workletNode = null;
                this.legacyGraph = false;

                if (AllpassNodeUI.shouldUseWorklet(ctx) && AllpassNodeUI.isWorkletReady(ctx)) {
                    try {
                        const defaultDelaySamples = this.msToSamples(this.delayMsValue, ctx);
                        const maxDelaySamples = Math.ceil(this.msToSamples(this.maxDelayMs, ctx)) + 8;
                        this.workletNode = new AudioWorkletNode(ctx, 'allpass-delay-processor', {
                            numberOfInputs: 1,
                            numberOfOutputs: 1,
                            outputChannelCount: [2],
                            channelCount: 2,
                            channelCountMode: 'explicit',
                            channelInterpretation: 'speakers',
                            parameterData: {
                                delaySamples: defaultDelaySamples,
                                gain: this.gainValue
                            },
                            processorOptions: {
                                maxDelaySamples,
                                defaultDelaySamples
                            }
                        });
                    } catch (err) {
                        console.error('Allpass worklet creation failed', err);
                        this.workletNode = null;
                    }
                }

                if (this.workletNode) {
                    this.inputNode.connect(this.workletNode);
                    this.workletNode.connect(this.outputNode);
                } else {
                    this.buildLegacyGraph(ctx);
                }

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputNode }];

                this.params = [
                    {
                        label: 'Delay (ms)',
                        type: 'range',
                        value: this.delayMsValue,
                        min: 1,
                        max: this.maxDelayMs,
                        scale: 'log',
                        onChange: (v, meta) => this.setDelayMs(v, ctx, meta)
                    },
                    {
                        label: 'Gain',
                        type: 'range',
                        value: this.gainValue,
                        min: 0,
                        max: 0.95,
                        scale: 'linear',
                        onChange: (v, meta) => this.setGain(v, ctx, meta)
                    }
                ];

                this.initializeParams();
                this.computeHeight();
            }

            buildLegacyGraph(ctx) {
                this.legacyGraph = true;
                this.sumIn = ctx.createGain();
                this.sumIn._debugLabel = `Allpass Sum In [${this.tag}]`;
                this.sumOut = ctx.createGain();
                this.sumOut._debugLabel = `Allpass Sum Out [${this.tag}]`;
                const maxDelaySeconds = Math.max(0.2, (this.maxDelayMs / 1000) + 0.05);
                this.delay = ctx.createDelay(maxDelaySeconds);
                this.delay._debugLabel = `Allpass Delay [${this.tag}]`;
                this.g_ff = ctx.createGain();
                this.g_ff._debugLabel = `Allpass Gff [${this.tag}]`;
                this.g_fb = ctx.createGain();
                this.g_fb._debugLabel = `Allpass Gfb [${this.tag}]`;

                this.inputNode.connect(this.sumIn);
                this.sumIn.connect(this.delay);
                this.delay.connect(this.sumOut);
                this.sumIn.connect(this.g_ff);
                this.g_ff.connect(this.sumOut);
                this.delay.connect(this.g_fb);
                this.g_fb.connect(this.sumIn);
                this.sumOut.connect(this.outputNode);

                this.delay.delayTime.value = this.defaultDelayMs / 1000;
                this.g_ff.gain.value = this.defaultGain;
                this.g_fb.gain.value = -this.defaultGain;
            }

            msToSamples(ms, ctxOverride) {
                const context = ctxOverride || this.context || (this.app ? this.app.audioCtx : null);
                const sr = context && context.sampleRate ? context.sampleRate : 48000;
                return (ms / 1000) * sr;
            }

            setDelayMs(ms, ctx, meta) {
                const clamped = Math.max(1, Math.min(this.maxDelayMs, ms));
                this.delayMsValue = clamped;
                const context = ctx || this.context;
                if (this.workletNode) {
                    const param = this.workletNode.parameters.get('delaySamples');
                    if (param && context) {
                        const samples = this.msToSamples(clamped, context);
                        const now = context.currentTime || 0;
                        if (typeof param.cancelScheduledValues === 'function') {
                            param.cancelScheduledValues(now);
                        }
                        if (meta && meta.immediate) {
                            param.setValueAtTime(samples, now);
                        } else if (typeof param.setTargetAtTime === 'function') {
                            param.setTargetAtTime(samples, now, 0.02);
                        } else {
                            param.value = samples;
                        }
                    }
                } else if (this.delay && context) {
                    this.delay.delayTime.setTargetAtTime(clamped / 1000, context.currentTime, 0.02);
                } else if (this.delay) {
                    this.delay.delayTime.value = clamped / 1000;
                }
            }

            setGain(v, ctx, meta) {
                const clamped = Math.max(0, Math.min(0.95, v));
                this.gainValue = clamped;
                const context = ctx || this.context;
                if (this.workletNode) {
                    const param = this.workletNode.parameters.get('gain');
                    if (param && context) {
                        const now = context.currentTime || 0;
                        if (typeof param.cancelScheduledValues === 'function') {
                            param.cancelScheduledValues(now);
                        }
                        if (meta && meta.immediate) {
                            param.setValueAtTime(clamped, now);
                        } else if (typeof param.setTargetAtTime === 'function') {
                            param.setTargetAtTime(clamped, now, 0.02);
                        } else {
                            param.value = clamped;
                        }
                    }
                } else {
                    if (this.g_ff && context) {
                        this.g_ff.gain.setTargetAtTime(clamped, context.currentTime, 0.02);
                    } else if (this.g_ff) {
                        this.g_ff.gain.value = clamped;
                    }
                    if (this.g_fb && context) {
                        this.g_fb.gain.setTargetAtTime(-clamped, context.currentTime, 0.02);
                    } else if (this.g_fb) {
                        this.g_fb.gain.value = -clamped;
                    }
                }
            }

            onRemoved() {
                if (this.workletNode) {
                    try { this.inputNode.disconnect(this.workletNode); } catch (e) { }
                    try { this.workletNode.disconnect(); } catch (e) { }
                    try { this.workletNode.port.postMessage({ type: 'reset' }); } catch (e) { }
                    this.workletNode = null;
                }
                if (this.legacyGraph) {
                    try { this.delay.disconnect(); } catch (e) { }
                    try { this.g_ff.disconnect(); } catch (e) { }
                    try { this.g_fb.disconnect(); } catch (e) { }
                    try { this.sumIn.disconnect(); } catch (e) { }
                    try { this.sumOut.disconnect(); } catch (e) { }
                }
                try { this.inputNode.disconnect(); } catch (e) { }
                try { this.outputNode.disconnect(); } catch (e) { }
            }
        }

        AllpassNodeUI.workletModulePath = 'worklets/allpass-delay-processor.js';

        AllpassNodeUI.shouldUseWorklet = function (ctx) {
            if (!ctx || !ctx.audioWorklet) return false;
            if (typeof AudioWorkletNode === 'undefined') return false;
            if (typeof window !== 'undefined') {
                const protocol = (window.location && window.location.protocol) ? window.location.protocol.toLowerCase() : '';
                if (protocol && protocol !== 'http:' && protocol !== 'https:') return false;
                if (typeof window.isSecureContext !== 'undefined' && window.isSecureContext === false) return false;
            }
            return true;
        };

        AllpassNodeUI.markUnsupported = function (ctx) {
            if (!ctx) return;
            if (!AllpassNodeUI._workletStates) {
                AllpassNodeUI._workletStates = new WeakMap();
            }
            AllpassNodeUI._workletStates.set(ctx, { ready: false, unsupported: true });
        };

        AllpassNodeUI.ensureWorklet = function (ctx) {
            if (!ctx) return Promise.resolve();

            if (!AllpassNodeUI.shouldUseWorklet(ctx)) {
                AllpassNodeUI.markUnsupported(ctx);
                return Promise.resolve();
            }

            if (!AllpassNodeUI._workletStates) {
                AllpassNodeUI._workletStates = new WeakMap();
            }

            const state = AllpassNodeUI._workletStates.get(ctx);
            if (state) {
                if (state.ready) return Promise.resolve();
                if (state.promise) return state.promise;
                if (state.unsupported) return Promise.resolve();
            }

            const modulePath = AllpassNodeUI.workletModulePath;
            if (!modulePath) {
                AllpassNodeUI.markUnsupported(ctx);
                return Promise.resolve();
            }

            const promise = ctx.audioWorklet.addModule(modulePath)
                .then(() => {
                    AllpassNodeUI._workletStates.set(ctx, { ready: true });
                })
                .catch(err => {
                    AllpassNodeUI.markUnsupported(ctx);
                    throw err;
                });

            AllpassNodeUI._workletStates.set(ctx, { ready: false, promise });
            return promise;
        };

        AllpassNodeUI.isWorkletReady = function (ctx) {
            if (!ctx || !AllpassNodeUI._workletStates) return false;
            const state = AllpassNodeUI._workletStates.get(ctx);
            return !!(state && state.ready);
        };

        AllpassNodeUI.isWorkletUnsupported = function (ctx) {
            if (!ctx || !AllpassNodeUI._workletStates) return false;
            const state = AllpassNodeUI._workletStates.get(ctx);
            return !!(state && state.unsupported);
        };


        class RingModNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Ring Mod', app);
                this.type = 'ringmod';
                this.width = 180;
                this.frequencyValue = 30;
                this.depthValue = 1;
                this.mixValue = 0.5;
                this.context = null;
                this.carrierOsc = null;
                this.carrierGain = null;
                this.inputNode = null;
                this.outputNode = null;
                this.dryGain = null;
                this.wetGain = null;
                this.ringGain = null;
            }

            initAudio(ctx) {
                this.context = ctx;

                this.inputNode = ctx.createGain();
                this.outputNode = ctx.createGain();
                this.dryGain = ctx.createGain();
                this.wetGain = ctx.createGain();
                this.ringGain = ctx.createGain();
                this.ringGain.gain.setValueAtTime(0, ctx.currentTime);

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputNode }];

                this.inputNode.connect(this.dryGain);
                this.dryGain.connect(this.outputNode);
                this.inputNode.connect(this.ringGain);
                this.ringGain.connect(this.wetGain);
                this.wetGain.connect(this.outputNode);

                this.carrierOsc = ctx.createOscillator();
                this.carrierOsc.type = 'sine';
                this.carrierOsc.frequency.value = this.frequencyValue;
                this.carrierGain = ctx.createGain();
                this.carrierGain.gain.setValueAtTime(this.depthValue, ctx.currentTime);
                this.carrierOsc.connect(this.carrierGain);
                this.carrierGain.connect(this.ringGain.gain);
                this.carrierOsc.start();

                this.params = [
                    {
                        label: 'Freq (Hz)', type: 'range', value: this.frequencyValue,
                        min: 0.5, max: 16000, scale: 'log',
                        onChange: (v) => this.setFrequency(v, ctx)
                    },
                    {
                        label: 'Depth', type: 'range', value: this.depthValue,
                        min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setDepth(v, ctx)
                    },
                    {
                        label: 'Mix', type: 'range', value: this.mixValue,
                        min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setMix(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();
            }

            setFrequency(value, ctx) {
                this.frequencyValue = value;
                const context = ctx || this.context;
                if (this.carrierOsc && context) {
                    this.carrierOsc.frequency.setTargetAtTime(value, context.currentTime, 0.01);
                }
            }

            setDepth(value, ctx) {
                this.depthValue = value;
                const context = ctx || this.context;
                if (this.carrierGain && context) {
                    this.carrierGain.gain.setTargetAtTime(value, context.currentTime, 0.01);
                }
            }

            setMix(value, ctx) {
                this.mixValue = value;
                const context = ctx || this.context;
                if (!context) return;
                const now = context.currentTime;
                if (this.dryGain) this.dryGain.gain.setTargetAtTime(1 - value, now, 0.01);
                if (this.wetGain) this.wetGain.gain.setTargetAtTime(value, now, 0.01);
            }

            onRemoved() {
                if (this.carrierOsc) {
                    try { this.carrierOsc.stop(); } catch (e) { }
                    this.carrierOsc.disconnect();
                    this.carrierOsc = null;
                }
                if (this.carrierGain) {
                    try { this.carrierGain.disconnect(); } catch (e) { }
                    this.carrierGain = null;
                }
            }
        }

        class DistortionNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Distortion', app);
                this.type = 'distortion';
                this.width = 170;
                this.context = null;
                this.driveValue = 0.5;
                this.preGainValue = 1;
                this.mixValue = 0.75;
                this.inputNode = null;
                this.outputNode = null;
                this.preGain = null;
                this.waveShaper = null;
                this.dryGain = null;
                this.wetGain = null;
            }

            initAudio(ctx) {
                this.context = ctx;

                this.inputNode = ctx.createGain();
                this.outputNode = ctx.createGain();
                this.preGain = ctx.createGain();
                this.waveShaper = ctx.createWaveShaper();
                this.waveShaper.oversample = '4x';
                this.dryGain = ctx.createGain();
                this.wetGain = ctx.createGain();

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputNode }];

                this.inputNode.connect(this.dryGain);
                this.dryGain.connect(this.outputNode);
                this.inputNode.connect(this.preGain);
                this.preGain.connect(this.waveShaper);
                this.waveShaper.connect(this.wetGain);
                this.wetGain.connect(this.outputNode);

                this.params = [
                    {
                        label: 'Drive', type: 'range', value: this.driveValue,
                        min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setDrive(v)
                    },
                    {
                        label: 'Pre Gain', type: 'range', value: this.preGainValue,
                        min: 0, max: 20, scale: 'linear',
                        onChange: (v) => this.setPreGain(v, ctx)
                    },
                    {
                        label: 'Mix', type: 'range', value: this.mixValue,
                        min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setMix(v, ctx)
                    }
                ];

                this.initializeParams();
                this.computeHeight();
            }

            setDrive(value) {
                this.driveValue = value;
                if (!this.waveShaper) return;
                const amount = Math.max(0, value) * 100;
                this.waveShaper.curve = this.makeDistortionCurve(amount);
            }

            setPreGain(value, ctx) {
                this.preGainValue = value;
                const context = ctx || this.context;
                if (this.preGain && context) {
                    this.preGain.gain.setTargetAtTime(value, context.currentTime, 0.01);
                }
            }

            setMix(value, ctx) {
                this.mixValue = value;
                const context = ctx || this.context;
                if (!context) return;
                const now = context.currentTime;
                if (this.dryGain) this.dryGain.gain.setTargetAtTime(1 - value, now, 0.01);
                if (this.wetGain) this.wetGain.gain.setTargetAtTime(value, now, 0.01);
            }

            makeDistortionCurve(amount) {
                const k = amount;
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = i * 2 / samples - 1;
                    curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
                }
                return curve;
            }

            onRemoved() {
                if (this.waveShaper) {
                    try { this.waveShaper.disconnect(); } catch (e) { }
                    this.waveShaper = null;
                }
            }
        }

        class InverterNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Inverter', app);
                this.type = 'inverter';
                this.width = 130;
            }

            initAudio(ctx) {
                this.node = ctx.createGain();
                this.node.gain.value = -1;

                this.inputs = [{ name: 'In', id: 0, node: this.node }];
                this.outputs = [{ name: 'Out', id: 0, node: this.node }];

                this.params = [{
                    label: 'Gain', type: 'range', value: -1, min: -2, max: 2, scale: 'linear',
                    onChange: (v) => this.node.gain.setTargetAtTime(v, ctx.currentTime, 0.01)
                }];

                this.initializeParams();
                this.computeHeight();
            }
        }

        class AdderNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Adder (3ch)', app);
                this.type = 'adder';
                this.width = 170;
                this.inputGains = [];
                this.sumGain = null;
            }

            initAudio(ctx) {
                this.sumGain = ctx.createGain();
                this.sumGain.gain.value = 1;

                this.inputGains = Array.from({ length: 3 }, () => ctx.createGain());
                this.inputGains.forEach(g => g.connect(this.sumGain));

                this.inputs = this.inputGains.map((g, idx) => ({ name: `In ${idx + 1}`, id: idx, node: g }));
                this.outputs = [{ name: 'Out', id: 0, node: this.sumGain }];

                this.params = this.inputGains.map((g, idx) => ({
                    label: `In ${idx + 1} Level`, type: 'range', value: 1, min: -2, max: 2, scale: 'linear',
                    onChange: (v) => g.gain.setTargetAtTime(v, ctx.currentTime, 0.01)
                }));

                this.initializeParams();
                this.computeHeight();
            }
        }

        class MultiplyNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Multiply', app);
                this.type = 'multiply';
                this.width = 150;
                this.context = null;
                this.constant = null;
                this.outputGain = null;
                this.signalValue = 0;
                this.factorValue = 1;
                this.currentValue = 0;
                this.subscribers = [];
            }

            initAudio(ctx) {
                this.context = ctx;
                this.constant = ctx.createConstantSource();
                this.constant.offset.value = 0;
                this.constant.start();

                this.outputGain = ctx.createGain();
                this.outputGain.gain.value = 1;
                this.constant.connect(this.outputGain);

                this.inputs = [];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];

                this.params = [
                    {
                        label: 'Input', type: 'range', value: 0, min: -1, max: 1, scale: 'linear',
                        modulationStrategy: 'override',
                        onChange: (v) => {
                            this.signalValue = Number.isFinite(v) ? v : 0;
                            this.updateOutput(ctx);
                        }
                    },
                    {
                        label: 'Factor', type: 'range', value: 1, min: -10000, max: 10000, scale: 'signedPow', power: 3,
                        modulationStrategy: 'override',
                        onChange: (v, meta) => {
                            const limit = 10000;
                            const safe = Math.max(-limit, Math.min(limit, Number.isFinite(v) ? v : 0));
                            this.factorValue = safe;
                            const paramRef = this.params && this.params[1];
                            if (paramRef) {
                                if (!meta || meta.fromAutomation !== true) {
                                    paramRef.value = safe;
                                }
                                paramRef.effectiveValue = safe;
                            }
                            this.updateOutput(ctx);
                        }
                    }
                ];

                this.initializeParams();
                this.computeHeight();
                this.updateOutput(ctx);
            }

            updateOutput(ctxOverride) {
                const next = this.signalValue * this.factorValue;
                if (!Number.isFinite(next)) return;
                const changed = Math.abs(next - this.currentValue) > 1e-6;
                this.currentValue = next;
                const ctx = ctxOverride || this.context;
                if (this.constant) {
                    if (ctx) {
                        this.constant.offset.setTargetAtTime(next, ctx.currentTime, 0.01);
                    } else {
                        this.constant.offset.value = next;
                    }
                }
                if (changed) {
                    this.notifySubscribers();
                }
            }

            getValue() {
                return this.currentValue;
            }

            addSubscriber(node, paramIndex) {
                this.subscribers.push({ node, paramIndex });
            }

            removeSubscriber(node, paramIndex) {
                this.subscribers = this.subscribers.filter(s => !(s.node === node && s.paramIndex === paramIndex));
            }

            notifySubscribers() {
                this.subscribers.forEach(({ node, paramIndex }) => {
                    if (node && typeof node.updateParam === 'function') {
                        node.updateParam(paramIndex);
                    }
                });
            }

            onRemoved() {
                if (this.constant) {
                    try { this.constant.stop(); } catch (e) { }
                    try { this.constant.disconnect(); } catch (e) { }
                    this.constant = null;
                }
                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                    this.outputGain = null;
                }
                this.subscribers = [];
                this.context = null;
                this.currentValue = 0;
            }
        }

        class AbsoluteNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Absolute', app);
                this.type = 'abs';
                this.width = 150;
                this.inputNode = null;
                this.shaper = null;
                this.outputGain = null;
            }

            initAudio(ctx) {
                this.inputNode = ctx.createGain();
                this.shaper = ctx.createWaveShaper();
                this.outputGain = ctx.createGain();

                this.shaper.curve = this.makeAbsCurve();
                this.shaper.oversample = '4x';

                this.inputNode.connect(this.shaper);
                this.shaper.connect(this.outputGain);

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];

                this.params = [{
                    label: 'Scale', type: 'range', value: 1, min: 0, max: 2, scale: 'linear',
                    onChange: (v) => this.outputGain.gain.setTargetAtTime(v, ctx.currentTime, 0.01)
                }];

                this.initializeParams();
                this.computeHeight();
            }

            makeAbsCurve() {
                const samples = 65536;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i / (samples - 1)) * 2 - 1;
                    curve[i] = Math.abs(x);
                }
                return curve;
            }

            onRemoved() {
                if (this.shaper) {
                    try { this.shaper.disconnect(); } catch (e) { }
                    this.shaper = null;
                }
            }
        }

        class ValueNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Value', app);
                this.type = 'value';
                this.width = 120;
                this.constant = null;
                this.subscribers = [];
                this.valueTransform = null;
            }

            initAudio(ctx) {
                this.constant = ctx.createConstantSource();
                this.constant.offset.value = 1;
                this.constant.start();

                this.outputGain = ctx.createGain();
                this.constant.connect(this.outputGain);

                this.inputs = [];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];
                this.params = [{
                    label: 'Value', type: 'range', value: 1, min: 0, max: 2, scale: 'linear',
                    onChange: (v) => {
                        if (this.constant) this.constant.offset.setTargetAtTime(v, ctx.currentTime, 0.01);
                        this.notifySubscribers();
                    }
                }];
                this.initializeParams();
                this.computeHeight();
            }

            getValue() {
                const param = this.params && this.params[0];
                if (!param) return 1;
                let base;
                if (typeof param.effectiveValue === 'number') base = param.effectiveValue;
                else if (typeof param.value === 'number') base = param.value;
                else base = 1;
                return this.applyValueTransform(base);
            }

            applyValueTransform(value) {
                if (!this.valueTransform || !this.valueTransform.type) return value;
                const transform = this.valueTransform.type;
                if (transform === 'samplesToMs') {
                    const sampleRate = (this.app && this.app.audioCtx && this.app.audioCtx.sampleRate) || 44100;
                    return (value / sampleRate) * 1000;
                }
                return value;
            }

            setValueTransform(transform) {
                if (!transform) {
                    this.valueTransform = null;
                } else if (typeof transform === 'string') {
                    this.valueTransform = { type: transform };
                } else {
                    this.valueTransform = { ...transform };
                }
                this.notifySubscribers();
            }

            addSubscriber(node, paramIndex) {
                this.subscribers.push({ node, paramIndex });
            }

            removeSubscriber(node, paramIndex) {
                this.subscribers = this.subscribers.filter(s => !(s.node === node && s.paramIndex === paramIndex));
            }

            notifySubscribers() {
                this.subscribers.forEach(({ node, paramIndex }) => {
                    if (node && typeof node.updateParam === 'function') {
                        node.updateParam(paramIndex);
                    }
                });
            }

            getExtraData() {
                const base = super.getExtraData();
                const extra = base ? { ...base } : {};
                if (this.title !== 'Value') extra.title = this.title;
                const param = this.params && this.params[0];
                if (param) {
                    const overrides = {};
                    if (param.label !== 'Value') overrides.label = param.label;
                    if (param.min !== 0) overrides.min = param.min;
                    if (param.max !== 2) overrides.max = param.max;
                    if (param.step !== undefined) overrides.step = param.step;
                    if (param.scale && param.scale !== 'linear') overrides.scale = param.scale;
                    if (Object.keys(overrides).length) {
                        extra.paramOverrides = { 0: overrides };
                    }
                }
                if (this.valueTransform) extra.valueTransform = { ...this.valueTransform };
                return Object.keys(extra).length ? extra : null;
            }

            restoreExtraData(data) {
                super.restoreExtraData(data);
                if (!data) return;
                if (data.title) this.title = data.title;
                if (data.paramOverrides && this.params) {
                    const overrides = data.paramOverrides[0];
                    if (overrides && this.params[0]) {
                        Object.assign(this.params[0], overrides);
                    }
                }
                if (data.valueTransform) {
                    this.valueTransform = { ...data.valueTransform };
                }
            }

            onRemoved() {
                if (this.constant) {
                    try { this.constant.stop(); } catch (e) { }
                    this.constant.disconnect();
                    this.constant = null;
                }
                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                    this.outputGain = null;
                }
                this.context = null;
            }
        }

        class MonoNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Mono', app);
                this.type = 'mono';
                this.width = 140;
                this.inputNode = null;
                this.splitter = null;
                this.sumGain = null;
                this.merger = null;
            }

            initAudio(ctx) {
                this.inputNode = ctx.createGain();
                this.splitter = ctx.createChannelSplitter(2);
                this.sumGain = ctx.createGain();
                this.sumGain.gain.value = 0.5; // average left and right
                this.merger = ctx.createChannelMerger(2);

                this.inputNode.connect(this.splitter);
                this.splitter.connect(this.sumGain, 0);
                this.splitter.connect(this.sumGain, 1);
                this.sumGain.connect(this.merger, 0, 0);
                this.sumGain.connect(this.merger, 0, 1);

                this.inputs = [{ name: 'In', id: 0, node: this.inputNode }];
                this.outputs = [{ name: 'Out', id: 0, node: this.merger }];
                this.params = [];
                this.initializeParams();
                this.computeHeight();
            }

            onRemoved() {
                if (this.inputNode) {
                    try { this.inputNode.disconnect(); } catch (e) { }
                }
                if (this.splitter) {
                    try { this.splitter.disconnect(); } catch (e) { }
                }
                if (this.sumGain) {
                    try { this.sumGain.disconnect(); } catch (e) { }
                }
                if (this.merger) {
                    try { this.merger.disconnect(); } catch (e) { }
                }
                this.inputNode = null;
                this.splitter = null;
                this.sumGain = null;
                this.merger = null;
            }
        }

        class SampleHoldNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Sample & Hold', app);
                this.type = 'samplehold';
                this.width = 180;
                this.baseTitle = 'Sample & Hold';
                this.context = null;
                this.signalIn = null;
                this.outputGain = null;
                this.workletNode = null;
                this.bypassGain = null;
                this.fallbackActive = false;
                this.heldValue = 0;
                this.subscribers = [];
                this.deferredInit = false;
                this.frequency = SampleHoldNodeUI.defaultFrequency;
                this.effectiveFrequency = this.frequency;
            }

            initAudio(ctx) {
                if (!ctx) return;
                this.context = ctx;

                this.setupCommonIO(ctx);

                this.inputs = [
                    { name: 'In', id: 0, node: this.signalIn }
                ];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];
                this.params = [
                    {
                        label: 'Frequency (Hz)',
                        type: 'range',
                        value: this.frequency,
                        min: SampleHoldNodeUI.minFrequency,
                        max: SampleHoldNodeUI.maxFrequency,
                        scale: 'log',
                        onChange: (v, meta) => this.setFrequency(v, ctx, meta)
                    }
                ];
                this.initializeParams();
                this.computeHeight();

                this.updateHeldValue(this.heldValue);
                this.prepareWorklet(ctx);
            }

            setupCommonIO(ctx) {
                if (!this.signalIn) {
                    this.signalIn = ctx.createGain();
                }
                if (!this.outputGain) {
                    this.outputGain = ctx.createGain();
                    this.outputGain.gain.value = 1;
                }
                if (!this.bypassGain) {
                    this.bypassGain = ctx.createGain();
                    this.bypassGain.gain.value = 1;
                }
            }

            prepareWorklet(ctx) {
                if (!SampleHoldNodeUI.shouldUseWorklet(ctx)) {
                    SampleHoldNodeUI.markUnsupported(ctx);
                    this.activateBypass(ctx);
                    console.warn('Sample & Hold worklet unavailable; node will pass the signal through.');
                    return;
                }

                this.activateBypass(ctx);

                const attachIfReady = () => {
                    if (this.context === ctx && !this.workletNode) {
                        this.initWorkletPipeline(ctx);
                    }
                };

                if (SampleHoldNodeUI.isWorkletReady(ctx)) {
                    attachIfReady();
                    return;
                }

                if (this.deferredInit) return;
                this.deferredInit = true;
                SampleHoldNodeUI.ensureWorklet(ctx)
                    .then(() => {
                        this.deferredInit = false;
                        attachIfReady();
                    })
                    .catch((err) => {
                        this.deferredInit = false;
                        SampleHoldNodeUI.markUnsupported(ctx);
                        console.error('Sample & Hold worklet load failed', err);
                        this.activateBypass(ctx);
                    });
            }

            initWorkletPipeline(ctx) {
                this.setupCommonIO(ctx);

                if (this.workletNode) {
                    try { this.workletNode.port.onmessage = null; } catch (e) { }
                    try { this.workletNode.disconnect(); } catch (e) { }
                    this.workletNode = null;
                }

                try {
                    this.workletNode = new AudioWorkletNode(ctx, 'sample-hold-processor', {
                        numberOfInputs: 1,
                        numberOfOutputs: 1,
                        outputChannelCount: [1],
                        channelCount: 1,
                        channelCountMode: 'explicit',
                        channelInterpretation: 'discrete',
                        parameterData: {
                            frequency: this.effectiveFrequency
                        }
                    });
                } catch (err) {
                    console.error('Sample & Hold worklet initialisation failed', err);
                    this.workletNode = null;
                    this.activateBypass(ctx);
                    return false;
                }

                this.signalIn.connect(this.workletNode, 0, 0);
                this.workletNode.connect(this.outputGain);

                if (this.fallbackActive) {
                    this.deactivateBypass();
                }

                this.updateFrequencyParam(ctx);

                this.workletNode.port.onmessage = (event) => {
                    this.handleWorkletMessage(event.data);
                };

                try {
                    this.workletNode.port.postMessage({ type: 'reset' });
                } catch (e) { }

                return true;
            }

            activateBypass(ctx) {
                if (this.fallbackActive) return;
                const context = ctx || this.context;
                if (!context) return;
                this.setupCommonIO(context);
                if (this.bypassGain) {
                    try { this.signalIn.connect(this.bypassGain); } catch (e) { }
                    try { this.bypassGain.connect(this.outputGain); } catch (e) { }
                } else if (this.signalIn && this.outputGain) {
                    try { this.signalIn.connect(this.outputGain); } catch (e) { }
                }
                this.fallbackActive = true;
            }

            deactivateBypass() {
                if (!this.fallbackActive) return;
                if (this.bypassGain) {
                    try { this.signalIn.disconnect(this.bypassGain); } catch (e) { }
                    try { this.bypassGain.disconnect(); } catch (e) { }
                } else if (this.signalIn && this.outputGain) {
                    try { this.signalIn.disconnect(this.outputGain); } catch (e) { }
                }
                this.fallbackActive = false;
            }

            setFrequency(value, ctx, meta) {
                const next = SampleHoldNodeUI.sanitizeFrequency(value);
                const param = this.params && this.params[0];
                const baseValue = param ? param.value : this.frequency;
                const metaFlag = meta && meta.fromAutomation === true;
                const inferredAutomation = !metaFlag && param ? Math.abs(next - baseValue) > 1e-6 : false;
                const isAutomation = metaFlag || inferredAutomation;

                if (isAutomation) {
                    if (Math.abs(next - this.effectiveFrequency) < 1e-6) return;
                    this.effectiveFrequency = next;
                    if (param) {
                        param.effectiveValue = next;
                    }
                    this.updateFrequencyParam(ctx, next);
                    return;
                }

                if (Math.abs(next - this.frequency) < 1e-6) {
                    this.effectiveFrequency = next;
                    if (param) {
                        param.effectiveValue = next;
                    }
                    this.updateFrequencyParam(ctx, next);
                    return;
                }

                this.frequency = next;
                this.effectiveFrequency = next;
                if (param) {
                    param.value = next > 0 ? next : SampleHoldNodeUI.minFrequency;
                    param.effectiveValue = next;
                }
                this.updateFrequencyParam(ctx, next);
            }

            updateFrequencyParam(ctx, overrideValue) {
                if (!this.workletNode) return;
                const context = ctx || this.context;
                const param = this.workletNode.parameters.get('frequency');
                if (!param) return;
                const target = typeof overrideValue === 'number' ? overrideValue : this.effectiveFrequency;
                if (context) {
                    param.setTargetAtTime(target, context.currentTime, 0.005);
                } else {
                    param.value = target;
                }
            }

            handleWorkletMessage(data) {
                if (typeof data === 'number') {
                    this.updateHeldValue(data);
                    return;
                }
                if (data && typeof data.value === 'number') {
                    this.updateHeldValue(data.value);
                }
            }

            initProcessorPipeline(ctx) {
                this.activateBypass(ctx);
                return false;
            }

            getValue() {
                return this.heldValue;
            }

            addSubscriber(node, paramIndex) {
                this.subscribers.push({ node, paramIndex });
            }

            removeSubscriber(node, paramIndex) {
                this.subscribers = this.subscribers.filter(s => !(s.node === node && s.paramIndex === paramIndex));
            }

            notifySubscribers() {
                this.subscribers.forEach(({ node, paramIndex }) => {
                    if (node && typeof node.updateParam === 'function') {
                        node.updateParam(paramIndex);
                    }
                });
            }

            onRemoved() {
                this.deferredInit = false;

                if (this.workletNode) {
                    try { this.workletNode.port.postMessage({ type: 'reset' }); } catch (e) { }
                    try { this.workletNode.port.onmessage = null; } catch (e) { }
                    try { this.workletNode.disconnect(); } catch (e) { }
                }
                this.workletNode = null;

                this.deactivateBypass();

                if (this.signalIn) {
                    try { this.signalIn.disconnect(); } catch (e) { }
                }
                this.signalIn = null;

                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                }
                this.outputGain = null;

                if (this.bypassGain) {
                    try { this.bypassGain.disconnect(); } catch (e) { }
                }
                this.bypassGain = null;

                this.heldValue = 0;
                this.context = null;
                this.subscribers = [];
                this.title = this.baseTitle;
            }

            updateHeldValue(value) {
                if (!Number.isFinite(value)) return;
                if (Math.abs(value - this.heldValue) < 1e-6) return;
                this.heldValue = value;
                this.notifySubscribers();
            }

            static shouldUseWorklet(ctx) {
                if (!ctx) return false;
                if (typeof window !== 'undefined') {
                    const protocol = window.location && typeof window.location.protocol === 'string'
                        ? window.location.protocol.toLowerCase()
                        : '';
                    if (protocol && protocol !== 'http:' && protocol !== 'https:') return false;
                    if (typeof window.isSecureContext !== 'undefined' && window.isSecureContext === false) return false;
                    if (!window.AudioWorkletNode) return false;
                }
                if (typeof AudioWorkletNode === 'undefined') return false;
                if (!ctx.audioWorklet) return false;
                if (SampleHoldNodeUI.isWorkletUnsupported(ctx)) return false;
                return true;
            }

            static markUnsupported(ctx) {
                if (!ctx) return;
                if (!SampleHoldNodeUI._workletStates) {
                    SampleHoldNodeUI._workletStates = new WeakMap();
                }
                SampleHoldNodeUI._workletStates.set(ctx, { ready: false, unsupported: true });
            }

            static ensureWorklet(ctx) {
                if (!ctx) return Promise.resolve();

                if (!SampleHoldNodeUI._workletStates) {
                    SampleHoldNodeUI._workletStates = new WeakMap();
                }

                const currentState = SampleHoldNodeUI._workletStates.get(ctx);
                const secure = (typeof window === 'undefined') || (typeof window.isSecureContext === 'undefined') || window.isSecureContext;
                const hasAPI = !!(ctx.audioWorklet && (typeof window === 'undefined' || window.AudioWorkletNode));

                if (!secure || !hasAPI) {
                    if (!currentState || !currentState.unsupported) {
                        SampleHoldNodeUI.markUnsupported(ctx);
                        console.warn('Sample & Hold node running in bypass; AudioWorklet requires a secure context.');
                    }
                    return Promise.resolve();
                }

                if (currentState && currentState.ready) return Promise.resolve();
                if (currentState && currentState.promise) return currentState.promise;

                const modulePath = SampleHoldNodeUI.workletModulePath;
                if (!modulePath) return Promise.resolve();

                const promise = ctx.audioWorklet.addModule(modulePath)
                    .then(() => {
                        SampleHoldNodeUI._workletStates.set(ctx, { ready: true });
                    })
                    .catch((err) => {
                        SampleHoldNodeUI.markUnsupported(ctx);
                        throw err;
                    });

                SampleHoldNodeUI._workletStates.set(ctx, { ready: false, promise });
                return promise;
            }

            static isWorkletReady(ctx) {
                if (!ctx || !SampleHoldNodeUI._workletStates) return false;
                const state = SampleHoldNodeUI._workletStates.get(ctx);
                return !!(state && state.ready);
            }

            static isWorkletUnsupported(ctx) {
                if (!ctx || !SampleHoldNodeUI._workletStates) return false;
                const state = SampleHoldNodeUI._workletStates.get(ctx);
                return !!(state && state.unsupported);
            }
        }

        SampleHoldNodeUI.defaultFrequency = 1000;
        SampleHoldNodeUI.minFrequency = 0.1;
        SampleHoldNodeUI.maxFrequency = 20000;
        SampleHoldNodeUI.workletModulePath = 'worklets/sample-hold-processor.js';
        SampleHoldNodeUI.sanitizeFrequency = function (value) {
            if (!Number.isFinite(value)) {
                return SampleHoldNodeUI.defaultFrequency;
            }
            if (value <= 0) {
                return 0;
            }
            if (value < SampleHoldNodeUI.minFrequency) {
                return SampleHoldNodeUI.minFrequency;
            }
            if (value > SampleHoldNodeUI.maxFrequency) {
                return SampleHoldNodeUI.maxFrequency;
            }
            return value;
        };

        class ChaosNodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'Chaos', app);
                this.type = 'chaos';
                this.width = 190;
                this.baseRate = 0.2;
                this.octaveCount = 4;
                this.depth = 1;
                this.seed = Math.random();
                this.context = null;
                this.sumGain = null;
                this.outputGain = null;
                this.voices = [];
                this.voiceStates = [];
                this.currentValue = 0;
                this.subscribers = [];
            }

            initAudio(ctx) {
                this.context = ctx;
                this.cleanupVoices();

                this.sumGain = ctx.createGain();
                this.sumGain.gain.value = 1;
                this.outputGain = ctx.createGain();
                this.outputGain.gain.value = this.depth;
                this.sumGain.connect(this.outputGain);

                this.inputs = [];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];
                this.params = [
                    {
                        label: 'Base Rate (Hz)', type: 'range', value: this.baseRate, min: 0.02, max: 5, scale: 'log',
                        defaultValue: this.baseRate,
                        onChange: (v) => this.setBaseRate(v, ctx)
                    },
                    {
                        label: 'Octaves', type: 'range', value: this.octaveCount, min: 1, max: 8, step: 1,
                        defaultValue: this.octaveCount,
                        onChange: (v) => this.setOctaves(v, ctx)
                    },
                    {
                        label: 'Depth', type: 'range', value: this.depth, min: 0, max: 1, scale: 'linear',
                        defaultValue: this.depth,
                        onChange: (v) => this.setDepth(v, ctx)
                    },
                    {
                        label: 'Seed', type: 'range', value: this.seed, min: 0, max: 1, scale: 'linear',
                        defaultValue: this.seed,
                        onChange: (v) => this.setSeed(v, ctx)
                    }
                ];
                this.initializeParams();
                this.computeHeight();
                this.app.registerDynamicNode(this);
                if (!this.voices.length) {
                    this.rebuildChaosVoices(ctx);
                }
            }

            setBaseRate(value, ctx) {
                const next = Math.max(0.02, Number.isFinite(value) ? value : this.baseRate);
                this.baseRate = next;
                if (this.params && this.params[0]) {
                    this.params[0].value = next;
                    this.params[0].effectiveValue = next;
                }
                if (this.context && this.sumGain) {
                    this.rebuildChaosVoices(ctx || this.context);
                }
            }

            setOctaves(value, ctx) {
                const next = Math.max(1, Math.round(Number.isFinite(value) ? value : this.octaveCount));
                this.octaveCount = next;
                if (this.params && this.params[1]) {
                    this.params[1].value = next;
                    this.params[1].effectiveValue = next;
                }
                if (this.context && this.sumGain) {
                    this.rebuildChaosVoices(ctx || this.context);
                }
            }

            setDepth(value, ctx) {
                const next = Math.max(0, Math.min(1, Number.isFinite(value) ? value : this.depth));
                this.depth = next;
                const context = ctx || this.context;
                if (this.outputGain && context) {
                    this.outputGain.gain.setTargetAtTime(next, context.currentTime, 0.02);
                } else if (this.outputGain) {
                    this.outputGain.gain.value = next;
                }
                if (this.params && this.params[2]) {
                    this.params[2].effectiveValue = next;
                }
                this.updateCurrentValue(this.computeValueFromStates());
            }

            setSeed(value, ctx) {
                let next = Number.isFinite(value) ? value : this.seed;
                next = ((next % 1) + 1) % 1;
                this.seed = next;
                if (this.params && this.params[3]) {
                    this.params[3].value = next;
                    this.params[3].effectiveValue = next;
                }
                if (this.context && this.sumGain) {
                    this.rebuildChaosVoices(ctx || this.context);
                }
            }

            rebuildChaosVoices(ctx) {
                const context = ctx || this.context;
                if (!context || !this.sumGain) return;
                this.cleanupVoices();

                const count = Math.max(1, Math.round(this.octaveCount));
                const base = Math.max(0.002, this.baseRate);
                const rand = ChaosNodeUI.createRandom(this.seed);
                const now = context.currentTime;
                const voices = [];
                const states = [];

                for (let i = 0; i < count; i++) {
                    const minFreq = base * Math.pow(2, i);
                    const maxFreq = minFreq * 2;
                    const freq = minFreq + (maxFreq - minFreq) * rand();
                    const phase = rand() * Math.PI * 2;

                    const osc = context.createOscillator();
                    osc.type = 'sine';
                    const real = new Float32Array(2);
                    const imag = new Float32Array(2);
                    real[1] = Math.cos(phase);
                    imag[1] = Math.sin(phase);
                    osc.setPeriodicWave(context.createPeriodicWave(real, imag, { disableNormalization: true }));
                    osc.frequency.setValueAtTime(freq, now);

                    const gain = context.createGain();
                    gain.gain.setValueAtTime(1 / count, now);
                    osc.connect(gain).connect(this.sumGain);
                    osc.start(now);

                    voices.push({ osc, gain });
                    states.push({ frequency: freq, phase });
                }

                this.voices = voices;
                this.voiceStates = states;
                this.updateCurrentValue(this.computeValueFromStates());
            }

            cleanupVoices() {
                if (!this.voices || !this.voices.length) {
                    this.voices = [];
                    this.voiceStates = [];
                    return;
                }
                const context = this.context;
                const now = context ? context.currentTime : 0;
                this.voices.forEach(({ osc, gain }) => {
                    if (context) {
                        if (gain) {
                            try { gain.gain.setTargetAtTime(0, now, 0.05); } catch (e) { }
                        }
                        if (osc) {
                            try { osc.stop(now + 0.1); } catch (e) { }
                        }
                        const localOsc = osc;
                        const localGain = gain;
                        setTimeout(() => {
                            if (localOsc) {
                                try { localOsc.disconnect(); } catch (e) { }
                            }
                            if (localGain) {
                                try { localGain.disconnect(); } catch (e) { }
                            }
                        }, 150);
                    } else {
                        if (osc) {
                            try { osc.stop(); } catch (e) { }
                            try { osc.disconnect(); } catch (e) { }
                        }
                        if (gain) {
                            try { gain.disconnect(); } catch (e) { }
                        }
                    }
                });
                this.voices = [];
                this.voiceStates = [];
            }

            tick(delta, now) {
                if (!this.voiceStates || !this.voiceStates.length) return;
                const twoPi = Math.PI * 2;
                let sum = 0;
                const invCount = 1 / this.voiceStates.length;
                for (let i = 0; i < this.voiceStates.length; i++) {
                    const state = this.voiceStates[i];
                    state.phase = (state.phase + state.frequency * delta * twoPi) % twoPi;
                    sum += Math.sin(state.phase);
                }
                const value = sum * invCount * this.depth;
                this.updateCurrentValue(value);
            }

            computeValueFromStates() {
                if (!this.voiceStates || !this.voiceStates.length) return 0;
                let sum = 0;
                for (let i = 0; i < this.voiceStates.length; i++) {
                    sum += Math.sin(this.voiceStates[i].phase);
                }
                return (sum / this.voiceStates.length) * this.depth;
            }

            updateCurrentValue(value) {
                if (!Number.isFinite(value)) return;
                if (Math.abs(value - this.currentValue) < 1e-4) return;
                this.currentValue = value;
                this.notifySubscribers();
            }

            getValue() {
                return this.currentValue;
            }

            addSubscriber(node, paramIndex) {
                this.subscribers.push({ node, paramIndex });
            }

            removeSubscriber(node, paramIndex) {
                this.subscribers = this.subscribers.filter(s => !(s.node === node && s.paramIndex === paramIndex));
            }

            notifySubscribers() {
                this.subscribers.forEach(({ node, paramIndex }) => {
                    if (node && typeof node.updateParam === 'function') {
                        node.updateParam(paramIndex);
                    }
                });
            }

            onRemoved() {
                this.app.unregisterDynamicNode(this);
                this.cleanupVoices();
                if (this.sumGain) {
                    try { this.sumGain.disconnect(); } catch (e) { }
                    this.sumGain = null;
                }
                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                    this.outputGain = null;
                }
                this.context = null;
                this.subscribers = [];
                this.currentValue = 0;
            }

            static createRandom(seed) {
                let normalized = Number.isFinite(seed) ? seed : Math.random();
                normalized = ((normalized % 1) + 1) % 1;
                let state = Math.floor(normalized * 2147483646) + 1;
                return () => {
                    state = (state * 16807) % 2147483647;
                    return state / 2147483647;
                };
            }
        }

        class LFONodeUI extends DSPNode {
            constructor(x, y, app) {
                super(x, y, 'LFO', app);
                this.type = 'lfo';
                this.width = 160;
                this.phase = 0;
                this.currentValue = 1;
                this.frequency = 1;
                this.depth = 0.5;
                this.center = 1;
                this.waveforms = ['sine', 'triangle', 'sawtooth', 'square', 'random'];
                this.waveformIndex = 0;
                this.randomMode = false;
                this.randomTimer = 0;
                this.randomValue = 0;
                this.oscillator = null;
                this.amplitude = null;
                this.offsetSource = null;
                this.outputGain = null;
                this.context = null;
                this.startTime = 0;
                this.subscribers = [];
            }

            initAudio(ctx) {
                this.context = ctx;
                this.outputGain = ctx.createGain();
                this.outputGain.gain.value = 1;

                this.oscillator = ctx.createOscillator();
                this.oscillator.type = 'sine';
                this.oscillator.frequency.value = this.frequency;

                this.amplitude = ctx.createGain();
                this.amplitude.gain.value = this.depth;

                this.offsetSource = ctx.createConstantSource();
                this.offsetSource.offset.value = this.center;

                this.oscillator.connect(this.amplitude);
                this.amplitude.connect(this.outputGain);
                this.offsetSource.connect(this.outputGain);

                this.oscillator.start();
                this.offsetSource.start();
                this.startTime = ctx.currentTime;

                this.inputs = [];
                this.outputs = [{ name: 'Out', id: 0, node: this.outputGain }];
                this.params = [
                    {
                        label: 'Rate (Hz)', type: 'range', value: 1, min: 0.05, max: 30, scale: 'log',
                        onChange: (v) => {
                            this.frequency = v;
                            if (this.oscillator) {
                                this.oscillator.frequency.setTargetAtTime(v, ctx.currentTime, 0.02);
                            }
                            if (this.randomMode) {
                                this.randomTimer = 0;
                            }
                        }
                    },
                    {
                        label: 'Depth', type: 'range', value: 0.5, min: 0, max: 1, scale: 'linear',
                        onChange: (v) => this.setDepth(v, ctx)
                    },
                    {
                        label: 'Center', type: 'range', value: 1, min: 0, max: 2, scale: 'linear',
                        onChange: (v) => this.setCenter(v, ctx)
                    },
                    {
                        label: 'Waveform', type: 'range', value: 0, min: 0, max: 4, step: 1, scale: 'linear',
                        onChange: (v) => this.setWaveform(v, ctx)
                    }
                ];
                this.initializeParams();
                this.currentValue = this.center;
                this.computeHeight();
                this.app.registerDynamicNode(this);
            }

            tick(delta, now) {
                if (!this.context) return;
                const freq = this.frequency;
                if (this.randomMode) {
                    const period = 1 / Math.max(0.0001, freq);
                    this.randomTimer += delta;
                    let sampled = false;
                    while (this.randomTimer >= period) {
                        this.randomTimer -= period;
                        this.triggerRandomSample(this.context);
                        sampled = true;
                    }
                    if (!sampled) {
                        const value = this.center + this.depth * this.randomValue;
                        this.updateCurrentValue(value);
                    }
                    return;
                }

                const depth = this.depth;
                const center = this.center;
                this.phase = (this.phase + delta * Math.max(0.0001, freq)) % 1;
                const p = this.phase;
                let shape;
                switch (this.waveformIndex) {
                    case 0:
                        shape = Math.sin(p * Math.PI * 2);
                        break;
                    case 1:
                        if (p < 0.25) shape = p * 4;
                        else if (p < 0.75) shape = 2 - p * 4;
                        else shape = p * 4 - 4;
                        break;
                    case 2:
                        shape = (2 * p) - 1;
                        break;
                    case 3:
                        shape = p < 0.5 ? 1 : -1;
                        break;
                    default:
                        shape = Math.sin(p * Math.PI * 2);
                        break;
                }
                const value = center + depth * shape;
                this.updateCurrentValue(value);
            }

            getValue() {
                return this.currentValue;
            }

            addSubscriber(node, paramIndex) {
                this.subscribers.push({ node, paramIndex });
            }

            removeSubscriber(node, paramIndex) {
                this.subscribers = this.subscribers.filter(s => !(s.node === node && s.paramIndex === paramIndex));
            }

            notifySubscribers() {
                this.subscribers.forEach(({ node, paramIndex }) => {
                    if (node && typeof node.updateParam === 'function') {
                        node.updateParam(paramIndex);
                    }
                });
            }

            setDepth(value, ctx) {
                this.depth = value;
                this.updateDepthGain(ctx || this.context);
                if (this.randomMode) {
                    const context = ctx || this.context;
                    if (this.offsetSource && context) {
                        const target = this.center + this.depth * this.randomValue;
                        this.offsetSource.offset.setTargetAtTime(target, context.currentTime, 0.02);
                        this.updateCurrentValue(target);
                    }
                }
            }

            setCenter(value, ctx) {
                this.center = value;
                const context = ctx || this.context;
                if (!this.offsetSource || !context) return;
                const target = this.randomMode ? value + this.depth * this.randomValue : value;
                this.offsetSource.offset.setTargetAtTime(target, context.currentTime, 0.02);
                this.updateCurrentValue(target);
            }

            setWaveform(value, ctx) {
                const context = ctx || this.context;
                const idx = Math.max(0, Math.min(this.waveforms.length - 1, Math.round(value)));
                this.waveformIndex = idx;
                this.randomMode = this.waveforms[idx] === 'random';
                if (this.params && this.params[3]) {
                    this.params[3].effectiveValue = idx;
                }
                if (this.randomMode) {
                    this.randomTimer = 0;
                    this.randomValue = 0;
                    this.updateDepthGain(context);
                    if (this.offsetSource && context) {
                        this.offsetSource.offset.setTargetAtTime(this.center, context.currentTime, 0.02);
                    }
                    this.triggerRandomSample(context);
                } else {
                    if (this.oscillator) {
                        this.oscillator.type = this.waveforms[idx];
                    }
                    this.updateDepthGain(context);
                    if (this.offsetSource && context) {
                        this.offsetSource.offset.setTargetAtTime(this.center, context.currentTime, 0.02);
                    }
                    this.updateCurrentValue(this.center);
                }
            }

            updateDepthGain(ctx) {
                const context = ctx || this.context;
                if (!this.amplitude || !context) return;
                const now = context.currentTime;
                const target = this.randomMode ? 0 : this.depth;
                this.amplitude.gain.setTargetAtTime(target, now, 0.02);
            }

            triggerRandomSample(ctx) {
                const context = ctx || this.context;
                this.randomValue = Math.random() * 2 - 1;
                const target = this.center + this.depth * this.randomValue;
                if (this.offsetSource && context) {
                    this.offsetSource.offset.setTargetAtTime(target, context.currentTime, 0.02);
                }
                this.updateCurrentValue(target);
            }

            updateCurrentValue(value) {
                if (Math.abs(value - this.currentValue) < 1e-4) return;
                this.currentValue = value;
                this.notifySubscribers();
            }

            onRemoved() {
                if (this.oscillator) {
                    try { this.oscillator.stop(); } catch (e) { }
                    this.oscillator.disconnect();
                    this.oscillator = null;
                }
                if (this.offsetSource) {
                    try { this.offsetSource.stop(); } catch (e) { }
                    this.offsetSource.disconnect();
                    this.offsetSource = null;
                }
                if (this.amplitude) {
                    this.amplitude.disconnect();
                    this.amplitude = null;
                }
                if (this.outputGain) {
                    try { this.outputGain.disconnect(); } catch (e) { }
                    this.outputGain = null;
                }
                this.app.unregisterDynamicNode(this);
            }
        }

        /* * MAIN APP */

        class App {

            debugParams() {
                this.nodes.forEach(node => {
                    if (typeof node.debugDump === 'function') {
                        node.debugDump();
                    }
                });
            }

            constructor() {

                AllpassNodeUI.prototype.debugDump = function() {
                    console.log('--- Allpass debug', this.id, '---');
                    console.log('g_ff:', this.g_ff.gain.value);
                    console.log('g_fb:', this.g_fb.gain.value);
                    console.log('delayTime:', this.delay.delayTime.value);
                };

                GainNodeUI.prototype.debugDump = function() {
                    console.log('--- Gain debug', this.id, '---');
                    console.log('gain:', this.outputNode.gain.value);
                };

                (function () {
                    const origConnect = AudioNode.prototype.connect;
                    const origDisconnect = AudioNode.prototype.disconnect;

                    // Use Map instead of WeakMap so we can iterate it.
                    const waGraph = new Map();

                    window.trueGraph = {};

                    function addEdge(src, dst) {
                        let set = waGraph.get(src);
                        if (!set) {
                            set = new Set();
                            waGraph.set(src, set);
                        }
                        set.add(dst);
                    }

                    function removeEdge(src, dst) {
                        const set = waGraph.get(src);
                        if (set) {
                            set.delete(dst);
                            if (!set.size) waGraph.delete(src);
                        }
                    }

                    AudioNode.prototype.connect = function (dest, ...rest) {
                        const s = this._debugLabel || this.toString();
                        const d = dest && (dest._debugLabel || dest.toString());
                        console.log('[WA connect]', s, '->', d);

                        addEdge(this, dest);
                        return origConnect.call(this, dest, ...rest);
                    };

                    AudioNode.prototype.disconnect = function (dest, ...rest) {
                        const s = this._debugLabel || this.toString();
                        const d = dest && (dest._debugLabel || dest.toString());
                        console.log('[WA disconnect]', s, '->', d || '(all)');

                        if (dest) removeEdge(this, dest);
                        else waGraph.delete(this);

                        return origDisconnect.call(this, dest, ...rest);
                    };

                    // Dump function now works because Map is iterable
                    window.dumpWebAudioGraph = function () {
                        console.log('--- Web Audio Graph ---');
                        waGraph.forEach((dstSet, src) => {
                            const s = src._debugLabel || src.toString();
                            const targets = [];
                            dstSet.forEach(dst => {
                                targets.push(dst._debugLabel || dst.toString());
                            });
                            console.log(s, '->', targets);
                        });
                    };

                    window.getWaGraph = function () {
                        return waGraph;
                    };
                })();

                this.canvas = document.getElementById('nodeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.connections = [];
                this.audioCtx = null;
                this.lastAudioSourceNode = null;
                this.activeSourceForLoad = null;
                this.selectedNodes = new Set();
                this.draggingSelection = null;
                this.draggingAnchor = null;

                this.draggingNode = null;
                this.draggingCable = null;
                this.draggingParam = null;
                this.hoveredPort = null;
                this.showDelaySamples = false;
                this.viewOffset = { x: 0, y: 0 };
                this.isPanning = false;
                this.panStart = null;
                this.panStartOffset = null;
                this.pitchOctaveOffset = 0;
                this.activeKeys = new Set();
                this.scaleKeyMap = {
                    KeyQ: 0,
                    KeyW: 2,
                    KeyE: 4,
                    KeyR: 5,
                    KeyT: 7,
                    KeyY: 9,
                    KeyU: 11,
                    KeyI: 12,
                    KeyO: 14,
                    KeyP: 16
                };
                this.sharpKeyMap = {
                    Digit2: 1,
                    Digit3: 3,
                    Digit5: 6,
                    Digit6: 8,
                    Digit7: 10,
                    Digit9: 13,
                    Digit0: 15
                };
                this.dynamicNodes = new Set();
                this.lastTickTime = performance.now();

                this.resize();
                window.addEventListener('resize', () => this.resize());
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.lastAudioSourceNode) this.lastAudioSourceNode.trigger(this.lastAudioSourceNode.lastType);
                        return;
                    }

                    const diatonic = this.scaleKeyMap.hasOwnProperty(e.code) ? this.scaleKeyMap[e.code] : undefined;
                    const sharp = this.sharpKeyMap.hasOwnProperty(e.code) ? this.sharpKeyMap[e.code] : undefined;
                    if (diatonic !== undefined || sharp !== undefined) {
                        if (this.activeKeys.has(e.code)) return;
                        this.activeKeys.add(e.code);
                        const source = this.lastAudioSourceNode;
                        if (source && source.isPitchable()) {
                            this.startAudio();
                            const semitone = diatonic !== undefined ? diatonic : sharp;
                            source.triggerNote(semitone, this.pitchOctaveOffset);
                        }
                        e.preventDefault();
                        return;
                    }

                    if (e.code === 'Equal' || e.code === 'NumpadAdd' || e.key === '+') {
                        this.adjustOctave(1);
                        e.preventDefault();
                        return;
                    }

                    if (e.code === 'Minus' || e.code === 'NumpadSubtract' || e.key === '-') {
                        this.adjustOctave(-1);
                        e.preventDefault();
                    }

                    if ((e.ctrlKey || e.metaKey) && e.code === 'KeyD') {
                        if (this.selectedNodes && this.selectedNodes.size) {
                            e.preventDefault();
                            this.duplicateSelectedNodes();
                        }
                        return;
                    }

                    if (e.key === 'Delete') {
                        if (this.selectedNodes && this.selectedNodes.size) {
                            this.deleteSelectedNodes();
                            e.preventDefault();
                        }
                        return;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (this.scaleKeyMap.hasOwnProperty(e.code) || this.sharpKeyMap.hasOwnProperty(e.code)) {
                        this.activeKeys.delete(e.code);
                    }
                });

                this.setupInput();

                // Init Defaults
                this.addNode('output', window.innerWidth - 200, window.innerHeight / 2 - 50);
                this.addNode('audio-source', 50, window.innerHeight / 2 - 100);
                this.lastAudioSourceNode = this.nodes[1];

                this.loop();
            }

            async startAudio() {
                if (this.audioCtx) {
                    if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();
                    if (SampleHoldNodeUI.shouldUseWorklet(this.audioCtx)) {
                        try {
                            await SampleHoldNodeUI.ensureWorklet(this.audioCtx);
                        } catch (err) {
                            console.error('Sample & Hold worklet preload failed', err);
                        }
                    }
                    if (AllpassNodeUI.shouldUseWorklet(this.audioCtx)) {
                        try {
                            await AllpassNodeUI.ensureWorklet(this.audioCtx);
                        } catch (err) {
                            console.error('Allpass worklet preload failed', err);
                        }
                    }
                    return;
                }
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                AudioUtils.init(this.audioCtx);
                if (SampleHoldNodeUI.shouldUseWorklet(this.audioCtx)) {
                    try {
                        await SampleHoldNodeUI.ensureWorklet(this.audioCtx);
                    } catch (err) {
                        console.error('Sample & Hold worklet preload failed', err);
                    }
                }
                if (AllpassNodeUI.shouldUseWorklet(this.audioCtx)) {
                    try {
                        await AllpassNodeUI.ensureWorklet(this.audioCtx);
                    } catch (err) {
                        console.error('Allpass worklet preload failed', err);
                    }
                }
                this.nodes.forEach(n => n.initAudio(this.audioCtx));

                const btn = document.getElementById('btn-start');
                btn.textContent = "Audio Running";
                btn.style.background = "#4dff88";
                btn.style.color = "#000";
            }

            reset() {
                if (this.connections.length > 0) {
                    this.connections.forEach(c => this.disconnect(c));
                }
                this.clearSelection();
                this.draggingSelection = null;
                this.draggingAnchor = null;
                this.viewOffset.x = 0;
                this.viewOffset.y = 0;
                this.isPanning = false;
                this.panStart = null;
                this.panStartOffset = null;
                this.canvas.style.cursor = 'default';
                this.connections = [];
                this.nodes.forEach(n => {
                    if (this.dynamicNodes.has(n)) this.unregisterDynamicNode(n);
                    if (typeof n.onRemoved === 'function') n.onRemoved();
                });
                this.dynamicNodes.clear();
                this.nodes = [];
                this.activeSourceForLoad = null;
                this.addNode('output', this.canvas.width - 200, this.canvas.height / 2 - 50);
                this.addNode('audio-source', 50, this.canvas.height / 2 - 100);
                this.lastAudioSourceNode = this.nodes[1];
            }

            async loadPreset(name) {
                if (!name) return;
                const presetId = name.trim();
                if (!presetId) return;
                try {
                    const response = await fetch(`presets/${encodeURIComponent(presetId)}.json`, { cache: 'no-cache' });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    await this.loadGraphFromData(data);
                } catch (err) {
                    console.error(`Failed to load preset "${presetId}"`, err);
                    alert(`Unable to load preset: ${presetId}`);
                }
            }

            // Helper to set params by index
            setNodeParam(node, idx, val) {
                if (node && node.params[idx]) {
                    node.params[idx].value = val;
                    node.updateParam(idx);
                }
            }

            registerDynamicNode(node) {
                this.dynamicNodes.add(node);
            }

            unregisterDynamicNode(node) {
                this.dynamicNodes.delete(node);
            }

            adjustOctave(delta) {
                const limit = 4;
                const next = Math.max(-limit, Math.min(limit, this.pitchOctaveOffset + delta));
                if (next === this.pitchOctaveOffset) return;
                this.pitchOctaveOffset = next;
                console.log(`Octave offset: ${this.pitchOctaveOffset}`);
            }

            getSignedPowSpans(param) {
                if (!param) return { neg: 1, pos: 1 };
                const min = typeof param.min === 'number' ? param.min : -1;
                const max = typeof param.max === 'number' ? param.max : 1;
                const neg = Math.max(0, -min);
                const pos = Math.max(0, max);
                return {
                    neg: neg > 0 ? neg : 0,
                    pos: pos > 0 ? pos : 0
                };
            }

            resolveSignedPowPower(param) {
                const candidate = param && typeof param.power === 'number' ? param.power : null;
                if (Number.isFinite(candidate) && candidate > 0) return candidate;
                return 3;
            }

            mapSignedPowNormToValue(param, norm) {
                const spans = this.getSignedPowSpans(param);
                const power = this.resolveSignedPowPower(param);
                const clampedNorm = Math.max(0, Math.min(1, norm));
                if (clampedNorm >= 0.5) {
                    if (spans.pos <= 0) return 0;
                    const local = (clampedNorm - 0.5) / 0.5;
                    const shaped = Math.pow(local, power);
                    return shaped * spans.pos;
                }
                if (spans.neg <= 0) return 0;
                const local = (0.5 - clampedNorm) / 0.5;
                const shaped = Math.pow(local, power);
                return -shaped * spans.neg;
            }

            mapSignedPowValueToNorm(param, value) {
                if (!Number.isFinite(value)) return 0.5;
                const spans = this.getSignedPowSpans(param);
                const power = this.resolveSignedPowPower(param);
                const min = typeof param.min === 'number' ? param.min : (spans.neg > 0 ? -spans.neg : 0);
                const max = typeof param.max === 'number' ? param.max : (spans.pos > 0 ? spans.pos : 0);
                const clamped = Math.max(min, Math.min(max, value));
                if (clamped >= 0) {
                    if (spans.pos <= 0) return 0.5;
                    const ratio = spans.pos === 0 ? 0 : Math.max(0, Math.min(1, clamped / spans.pos));
                    const shaped = Math.pow(ratio, 1 / power);
                    return 0.5 + 0.5 * shaped;
                }
                if (spans.neg <= 0) return 0.5;
                const ratio = spans.neg === 0 ? 0 : Math.max(0, Math.min(1, (-clamped) / spans.neg));
                const shaped = Math.pow(ratio, 1 / power);
                return 0.5 - 0.5 * shaped;
            }

            // Map a pointer position into the appropriate slider value for the active parameter.
            setParamValueFromPointer(target, pointerX) {
                if (!target || !target.node || !target.param) return;
                const node = target.node;
                const param = target.param;
                const sliderX = node.x + 10;
                const sliderWidth = node.width - 20;
                if (sliderWidth <= 0) return;

                let norm = (pointerX - sliderX) / sliderWidth;
                norm = Math.max(0, Math.min(1, norm));

                let newVal;
                if (param.scale === 'log') {
                    newVal = AudioUtils.toLog(norm, param.min, param.max);
                } else if (param.scale === 'signedPow') {
                    newVal = this.mapSignedPowNormToValue(param, norm);
                } else {
                    newVal = param.min + (param.max - param.min) * norm;
                }

                if (param.step) {
                    newVal = Math.round(newVal / param.step) * param.step;
                }

                newVal = Math.min(param.max, Math.max(param.min, newVal));

                if (Math.abs(newVal - param.value) < 1e-6) return;
                param.value = newVal;
                if (typeof target.index === 'number') {
                    node.updateParam(target.index);
                } else {
                    param.onChange(newVal);
                }
            }

            resetParamToDefault(node, index) {
                if (!node || !node.params || !node.params[index]) return false;
                const param = node.params[index];
                if (param.defaultValue === undefined) return false;
                const resetValue = param.defaultValue;
                if (typeof resetValue === 'number' && Math.abs(param.value - resetValue) < 1e-6) {
                    return true;
                }
                param.value = resetValue;
                node.updateParam(index);
                return true;
            }

            /* SAVE / LOAD SYSTEM */

            async loadGraphFromData(data) {
                if (!data) return;

                await this.startAudio();

                this.connections.forEach(c => this.disconnect(c));
                this.connections = [];
                this.nodes.forEach(n => {
                    if (this.dynamicNodes.has(n)) this.unregisterDynamicNode(n);
                    if (typeof n.onRemoved === 'function') n.onRemoved();
                });
                this.dynamicNodes.clear();
                this.nodes = [];
                this.activeSourceForLoad = null;
                this.clearSelection();
                this.draggingSelection = null;
                this.draggingAnchor = null;
                this.draggingNode = null;
                this.draggingCable = null;
                this.draggingParam = null;
                this.hoveredPort = null;
                if (this.viewOffset) {
                    this.viewOffset.x = 0;
                    this.viewOffset.y = 0;
                }
                this.isPanning = false;
                if (this.canvas) {
                    this.canvas.style.cursor = 'default';
                }

                const nodeMap = {};
                (data.nodes || []).forEach(nData => {
                    if (!nData || !nData.type) return;
                    const node = this.createNodeInstance(nData.type, nData.x, nData.y);
                    node.id = nData.id || crypto.randomUUID();
                    node.initAudio(this.audioCtx);

                    if (nData.extra) {
                        node.restoreExtraData(nData.extra);
                    }

                    if (Array.isArray(nData.params)) {
                        nData.params.forEach((val, i) => {
                            if (node.params && node.params[i]) {
                                this.setNodeParam(node, i, val);
                            }
                        });
                    }

                    if (typeof node.computeHeight === 'function') {
                        node.computeHeight();
                    }

                    this.nodes.push(node);
                    nodeMap[node.id] = node;
                });

                (data.connections || []).forEach(c => {
                    if (!c) return;
                    const from = nodeMap[c.fromNodeId];
                    const to = nodeMap[c.toNodeId];
                    if (from && to) {
                        this.connect(from, c.fromPort, to, c.toPort, c.kind || 'audio', c.mode);
                    }
                });

                const sources = this.nodes.filter(n => n.type === 'audio-source' || n.type === 'sampler');
                if (sources.length > 0) {
                    this.lastAudioSourceNode = sources[0];
                }
            }

            saveGraph() {
                const data = {
                    nodes: this.nodes.map(n => n.getSnapshot()),
                    connections: this.connections.map(c => ({
                        fromNodeId: c.fromNode.id,
                        fromPort: c.fromPort,
                        toNodeId: c.toNode.id,
                        toPort: c.toPort,
                        kind: c.kind,
                        paramIndex: c.paramIndex,
                        mode: c.mode
                    }))
                };
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'dps-playground-patch.json';
                a.click();
            }

            loadGraph(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        await this.loadGraphFromData(data);
                    } catch (err) {
                        console.error('Failed to load graph file', err);
                        alert('Unable to load patch file.');
                    } finally {
                        input.value = '';
                    }
                };
                reader.readAsText(file);
            }

            addNode(type, x, y) {
                console.log(`Adding node of type: ${type}`);
                if (x === undefined) x = this.canvas.width / 2 - 70 - this.viewOffset.x;
                if (y === undefined) y = this.canvas.height / 2 - 50 - this.viewOffset.y;

                // Snap to grid
                x = Math.round(x / 20) * 20;
                y = Math.round(y / 20) * 20;

                const n = this.createNodeInstance(type, x, y);
                if (this.audioCtx) n.initAudio(this.audioCtx);
                this.nodes.push(n);
                if (type === 'audio-source' || type === 'sampler') this.lastAudioSourceNode = n;
                console.log(`finished adding node ID: ${n.id}`);
                return n; // Return for scripting
            }

            createNodeInstance(type, x, y) {
                switch (type) {
                    case 'output': return new OutputNode(x, y, this);
                    case 'audio-source': return new AudioSourceNode(x, y, this);
                    case 'sampler': return new AudioSourceNode(x, y, this);
                    case 'gain': return new GainNodeUI(x, y, this);
                    case 'mixer': return new MixerNodeUI(x, y, this);
                    case 'wetdry': return new WetDryNodeUI(x, y, this);
                    case 'panner': return new PannerNodeUI(x, y, this);
                    case 'delay': return new DelayNodeUI(x, y, this);
                    case 'comb': return new CombNodeUI(x, y, this);
                    case 'allpass-delay': return new AllpassNodeUI(x, y, this);
                    case 'lpf': return new BiquadNodeUI(x, y, this, 'lowpass');
                    case 'hpf': return new BiquadNodeUI(x, y, this, 'highpass');
                    case 'bpf': return new BiquadNodeUI(x, y, this, 'bandpass');
                    case 'notch': return new BiquadNodeUI(x, y, this, 'notch');
                    case 'diffuser': return new DiffuserNodeUI(x, y, this);
                    case 'fdn-scalable': return new FDNNodeUI(x, y, this);
                    case 'ringmod': return new RingModNodeUI(x, y, this);
                    case 'pitch-shifter': return new PitchShiftNodeUI(x, y, this);
                    case 'mono': return new MonoNodeUI(x, y, this);
                    case 'allpass': return new BiquadNodeUI(x, y, this, 'allpass');
                    case 'distortion': return new DistortionNodeUI(x, y, this);
                    case 'adder': return new AdderNodeUI(x, y, this);
                    case 'multiply': return new MultiplyNodeUI(x, y, this);
                    case 'inverter': return new InverterNodeUI(x, y, this);
                    case 'abs': return new AbsoluteNodeUI(x, y, this);
                    case 'samplehold': return new SampleHoldNodeUI(x, y, this);
                    case 'lfo': return new LFONodeUI(x, y, this);
                    case 'chaos': return new ChaosNodeUI(x, y, this);
                    case 'value': return new ValueNodeUI(x, y, this);
                    default: return new GainNodeUI(x, y, this);
                }
            }

            deleteNode(node) {
                console.log(`Deleting node ID: ${node.id}`);
                if (node.type === 'output') return; // Keep output
                if (this.dynamicNodes.has(node)) this.unregisterDynamicNode(node);
                if (typeof node.onRemoved === 'function') node.onRemoved();
                if (this.activeSourceForLoad === node) this.activeSourceForLoad = null;
                if (this.selectedNodes.has(node)) {
                    this.selectedNodes.delete(node);
                }
                if (this.draggingSelection) {
                    this.draggingSelection = this.draggingSelection.filter(entry => entry.node !== node);
                    if (!this.draggingSelection.length) {
                        this.draggingSelection = null;
                        this.draggingAnchor = null;
                        this.draggingNode = null;
                    } else if (this.draggingAnchor && this.draggingAnchor.node === node) {
                        this.draggingAnchor = this.draggingSelection[0];
                        this.draggingNode = this.draggingAnchor.node;
                    }
                }

                this.connections = this.connections.filter(c => {
                    if (c.fromNode === node || c.toNode === node) {
                        this.disconnect(c);
                        return false;
                    }
                    return true;
                });
                this.nodes = this.nodes.filter(n => n !== node);
                console.log(`Deleted node ID: ${node.id}`);
            }

            connect(fromNode, fromPort, toNode, toPort, targetKind = 'audio', modeOverride) {
                if (targetKind === 'param') {
                    const paramInput = toNode.paramInputs && toNode.paramInputs[toPort];
                    if (!paramInput) return;
                    const modList = toNode.paramModulators[paramInput.paramIndex] || (toNode.paramModulators[paramInput.paramIndex] = []);
                    if (modList.some(entry => entry.node === fromNode)) return;
                    const param = toNode.params && toNode.params[paramInput.paramIndex];
                    const defaultMode = modeOverride
                        || (param && (param.modulationStrategy || param.defaultModulationStrategy))
                        || 'multiply';
                    modList.push({ node: fromNode, mode: defaultMode });
                    if (typeof fromNode.addSubscriber === 'function') {
                        fromNode.addSubscriber(toNode, paramInput.paramIndex);
                    }
                    toNode.updateParam(paramInput.paramIndex);
                    this.connections.push({ kind: 'param', fromNode, fromPort, toNode, toPort, paramIndex: paramInput.paramIndex, mode: defaultMode });
                    console.log(`Connected param modulator: ${fromNode.title} ID ${fromNode.id} -> ${toNode.title} ID ${toNode.id} [${paramInput.paramIndex}] (${defaultMode})`);
                    return;
                }

                const exists = this.connections.some(c =>
                    c.kind === 'audio' &&
                    c.fromNode === fromNode &&
                    c.fromPort === fromPort &&
                    c.toNode === toNode &&
                    c.toPort === toPort
                );
                if (exists) {
                    console.log(`Connection already exists: ${fromNode.title} ID ${fromNode.id} -> ${toNode.title} ID ${toNode.id} [${fromPort} -> ${toPort}] skipping`);
                    return; // already connected, do nothing
                }

                const fromOut = fromNode.outputs[fromPort] && fromNode.outputs[fromPort].node;
                const toIn = toNode.inputs[toPort] && toNode.inputs[toPort].node;

                if (fromOut && toIn) {
                    try {
                        // Defensive: ensure there is at most *one* connection
                        fromOut.disconnect(toIn);
                    } catch (e) {
                        // disconnect may throw if there wasn't a connection; ignore
                    }
                    try {
                        fromOut.connect(toIn);
                    } catch (e) {
                        console.error("Connection failed", e);
                    }
                }
                this.connections.push({ kind: 'audio', fromNode, fromPort, toNode, toPort });
                console.log(`Connected: ${fromNode.title} ID ${fromNode.id} -> ${toNode.title} ID ${toNode.id} [${fromPort} -> ${toPort}]`);
            }

            disconnect(conn) {
                if (conn.kind === 'param') {
                    const { toNode, paramIndex, fromNode } = conn;
                    if (toNode && typeof toNode.removeParamModulator === 'function') {
                        toNode.removeParamModulator(paramIndex, fromNode);
                        toNode.updateParam(paramIndex);
                    }
                    if (fromNode && typeof fromNode.removeSubscriber === 'function') {
                        fromNode.removeSubscriber(toNode, paramIndex);
                    }

                    console.log(`Disconnected param modulator: ${fromNode.title} ID ${fromNode.id} -> ${toNode.title} ID ${toNode.id} [${paramIndex}]`);

                    return;
                }

                const src = conn.fromNode.outputs[conn.fromPort].node;
                const dest = conn.toNode.inputs[conn.toPort].node;
                if (src && dest) {
                    try {
                        src.disconnect(dest);
                        console.log(`Disconnected: ${conn.fromNode.title} ID ${conn.fromNode.id} -> ${conn.toNode.title} ID ${conn.toNode.id} [${conn.fromPort} -> ${conn.toPort}]`);
                    } catch (e) { }
                }
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            clearSelection() {
                if (!this.selectedNodes.size) return;
                this.selectedNodes.clear();
            }

            selectSingleNode(node) {
                this.selectedNodes.clear();
                if (node) this.selectedNodes.add(node);
            }

            addNodeToSelection(node) {
                if (node) this.selectedNodes.add(node);
            }

            beginDragSelection(anchorNode, pointerX, pointerY) {
                if (!anchorNode) return;
                if (!this.selectedNodes.has(anchorNode)) {
                    this.selectSingleNode(anchorNode);
                }

                const entries = Array.from(this.selectedNodes).map(node => ({
                    node,
                    startX: node.x,
                    startY: node.y,
                    offsetX: pointerX - node.x,
                    offsetY: pointerY - node.y
                }));

                const anchor = entries.find(entry => entry.node === anchorNode) || entries[0];
                this.draggingSelection = entries;
                this.draggingAnchor = anchor;
                this.draggingNode = anchorNode;

                const orderedNodes = entries
                    .map(entry => ({ node: entry.node, index: this.nodes.indexOf(entry.node) }))
                    .filter(item => item.index >= 0)
                    .sort((a, b) => a.index - b.index);

                orderedNodes.forEach(({ node }) => {
                    const idx = this.nodes.indexOf(node);
                    if (idx >= 0) this.nodes.splice(idx, 1);
                });
                orderedNodes.forEach(({ node }) => this.nodes.push(node));
            }

            findConnectionAt(x, y, tolerance = 12) {
                for (let i = this.connections.length - 1; i >= 0; i--) {
                    const c = this.connections[i];
                    const p1 = c.fromNode.getPortPos(false, c.fromPort);
                    const p2 = c.kind === 'param'
                        ? c.toNode.getParamInputPos(c.toPort)
                        : c.toNode.getPortPos(true, c.toPort);

                    const cp1x = p1.x + Math.abs(p2.x - p1.x) * 0.5;
                    const cp2x = p2.x - Math.abs(p2.x - p1.x) * 0.5;

                    for (let t = 0; t <= 1; t += 0.05) {
                        const it = 1 - t;
                        const bx = (it * it * it) * p1.x + 3 * (it * it) * t * cp1x + 3 * it * (t * t) * cp2x + (t * t * t) * p2.x;
                        const by = (it * it * it) * p1.y + 3 * (it * it) * t * p1.y + 3 * it * (t * t) * p2.y + (t * t * t) * p2.y;
                        if (Math.hypot(x - bx, y - by) <= tolerance) {
                            return c;
                        }
                    }
                }
                return null;
            }

            cycleParamConnectionMode(connection) {
                if (!connection || connection.kind !== 'param') return;
                const sequence = ['multiply', 'add', 'override'];
                const current = connection.mode || 'multiply';
                const nextMode = sequence[(sequence.indexOf(current) + 1) % sequence.length];
                connection.mode = nextMode;
                const paramIndex = connection.paramIndex;
                const modList = connection.toNode.paramModulators && connection.toNode.paramModulators[paramIndex];
                if (modList) {
                    const entry = modList.find(item => item.node === connection.fromNode);
                    if (entry) entry.mode = nextMode;
                }
                connection.toNode.updateParam(paramIndex);
            }

            deleteSelectedNodes() {
                if (!this.selectedNodes.size) return;
                const toDelete = Array.from(this.selectedNodes);
                toDelete.forEach(node => this.deleteNode(node));
                this.clearSelection();
            }

            duplicateSelectedNodes() {
                if (!this.selectedNodes.size) return;
                const originals = Array.from(this.selectedNodes);
                const offsetX = 40;
                const offsetY = 40;
                const mapping = new Map();
                const clones = [];
                const originalLastSource = this.lastAudioSourceNode;

                originals.forEach(source => {
                    const extra = typeof source.getExtraData === 'function' ? source.getExtraData() : null;
                    const clone = this.addNode(source.type, source.x + offsetX, source.y + offsetY);
                    if (!clone) return;
                    if (extra && typeof clone.restoreExtraData === 'function') {
                        clone.restoreExtraData(extra);
                    }
                    if (source.params && clone.params) {
                        source.params.forEach((param, idx) => {
                            if (!clone.params[idx]) return;
                            clone.params[idx].value = param.value;
                            if (param.modulationStrategy) {
                                clone.params[idx].modulationStrategy = param.modulationStrategy;
                            }
                            if (param.defaultModulationStrategy !== undefined) {
                                clone.params[idx].defaultModulationStrategy = param.defaultModulationStrategy;
                            }
                            clone.updateParam(idx);
                        });
                    }
                    if (source.type === 'audio-source') {
                        clone.lastType = source.lastType;
                        clone.baseFrequency = source.baseFrequency;
                        clone.basePlaybackRate = source.basePlaybackRate;
                        clone.noteRelease = source.noteRelease;
                        clone.customBuffer = source.customBuffer;
                    }
                    if (typeof clone.computeHeight === 'function') {
                        clone.computeHeight();
                    }
                    mapping.set(source, clone);
                    clones.push(clone);
                });

                if (!clones.length) return;

                const originalsSet = new Set(originals);
                const connectionsToClone = this.connections.filter(conn =>
                    originalsSet.has(conn.fromNode) && originalsSet.has(conn.toNode)
                );

                connectionsToClone.forEach(conn => {
                    const fromClone = mapping.get(conn.fromNode);
                    const toClone = mapping.get(conn.toNode);
                    if (!fromClone || !toClone) return;
                    this.connect(fromClone, conn.fromPort, toClone, conn.toPort, conn.kind, conn.mode);
                });

                if (originalLastSource && mapping.has(originalLastSource)) {
                    this.lastAudioSourceNode = mapping.get(originalLastSource);
                } else {
                    this.lastAudioSourceNode = originalLastSource;
                }

                this.clearSelection();
                clones.forEach(node => this.selectedNodes.add(node));
            }

            setupInput() {
                document.getElementById('btn-start').addEventListener('click', () => this.startAudio());
                const delayUnitButton = document.getElementById('btn-toggle-delay-units');
                if (delayUnitButton) {
                    delayUnitButton.addEventListener('click', () => {
                        this.showDelaySamples = !this.showDelaySamples;
                        delayUnitButton.textContent = `Delay Units: ${this.showDelaySamples ? 'samples' : 'ms'}`;
                    });
                }

                // File input delegation
                const audioInput = document.getElementById('audio-input');
                audioInput.addEventListener('change', (e) => {
                    if (this.activeSourceForLoad && e.target.files[0]) {
                        this.activeSourceForLoad.loadCustomSample(e.target.files[0]);
                    }
                    this.activeSourceForLoad = null;
                    audioInput.value = '';
                });

                const getMousePos = (e) => {
                    const r = this.canvas.getBoundingClientRect();
                    return {
                        x: e.clientX - r.left - this.viewOffset.x,
                        y: e.clientY - r.top - this.viewOffset.y
                    };
                };

                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 1) {
                        e.preventDefault();
                        this.isPanning = true;
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.panStartOffset = { x: this.viewOffset.x, y: this.viewOffset.y };
                        this.canvas.style.cursor = 'grabbing';
                        this.draggingSelection = null;
                        this.draggingAnchor = null;
                        this.draggingNode = null;
                        this.draggingCable = null;
                        this.draggingParam = null;
                        this.hoveredPort = null;
                        return;
                    }

                    const { x, y } = getMousePos(e);
                    const wantsToggle = e.ctrlKey || e.metaKey;
                    const wantsAdd = e.shiftKey;
                    const additiveSelect = wantsToggle || wantsAdd;

                    // Reverse iterate for Z-index (top first)
                    for (let i = this.nodes.length - 1; i >= 0; i--) {
                        const n = this.nodes[i];

                        const isAudioSourceNode = n.type === 'audio-source' || n.type === 'sampler';

                        // 1. Check Audio Source UI
                        if (isAudioSourceNode) {
                            const btnW = 60; const btnH = 20; const gap = 5;
                            const buttons = ['kick', 'snare', 'hh', 'sine', 'saw', 'square', 'triangle', 'noise', 'mic', 'custom'];
                            let bx = n.x + 10, by = n.y + n.headerHeight + 10;

                            // Audio Triggers
                            for (let j = 0; j < buttons.length; j++) {
                                if (x >= bx && x <= bx + btnW && y >= by && y <= by + btnH) {
                                    n.trigger(buttons[j]);
                                    return;
                                }
                                bx += btnW + gap;
                                if (bx + btnW > n.x + n.width - 10) { bx = n.x + 10; by += btnH + gap; }
                            }

                            // Load Button
                            const loadX = n.x + 10;
                            const loadY = by + 5;
                            const loadW = 90;
                            const loadH = 22;
                            if (x >= loadX && x <= loadX + loadW && y >= loadY && y <= loadY + loadH) {
                                this.activeSourceForLoad = n;
                                document.getElementById('audio-input').click();
                                return;
                            }
                        }

                        // 2. Check Output Ports first so they are easy to grab near sliders
                        for (let j = 0; j < n.outputs.length; j++) {
                            const p = n.getPortPos(false, j);
                            if (Math.hypot(x - p.x, y - p.y) < 10) {
                                this.draggingSelection = null;
                                this.draggingAnchor = null;
                                this.draggingNode = null;
                                this.draggingCable = { fromNode: n, fromPort: j, x: x, y: y };
                                return;
                            }
                        }

                        // 3. Check Params (slider body only)
                        const paramBaseOffset = isAudioSourceNode ? 100 : 24;
                        const paramSpacing = n.paramSpacing || 48;
                        for (let idx = 0; idx < n.params.length; idx++) {
                            const p = n.params[idx];
                            const sliderX = n.x + 10;
                            const sliderWidth = n.width - 20;
                            const slotTop = typeof n.getParamSlotTop === 'function'
                                ? n.getParamSlotTop(idx)
                                : n.y + n.headerHeight + paramBaseOffset + (idx * paramSpacing);
                            const captureTop = slotTop + 16;
                            const captureBottom = slotTop + paramSpacing;

                            if (x >= sliderX && x <= sliderX + sliderWidth && y >= captureTop && y <= captureBottom) {
                                this.draggingSelection = null;
                                this.draggingAnchor = null;
                                this.draggingNode = null;
                                this.draggingParam = { node: n, param: p, index: idx };
                                this.setParamValueFromPointer(this.draggingParam, x);
                                return;
                            }
                        }

                        // 4. Node Drag
                        if (x >= n.x && x <= n.x + n.width && y >= n.y && y <= n.y + n.headerHeight) {
                            if (wantsToggle) {
                                if (this.selectedNodes.has(n)) {
                                    this.selectedNodes.delete(n);
                                    this.draggingSelection = null;
                                    this.draggingAnchor = null;
                                    this.draggingNode = null;
                                    return;
                                }
                                this.addNodeToSelection(n);
                            } else if (wantsAdd) {
                                this.addNodeToSelection(n);
                            } else if (this.selectedNodes.has(n)) {
                                // Already part of the selection, keep existing group
                            } else {
                                this.selectSingleNode(n);
                            }
                            this.beginDragSelection(n, x, y);
                            return;
                        }
                    }

                    if (!wantsAdd && !wantsToggle) {
                        this.clearSelection();
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isPanning) return;
                    const { x, y } = getMousePos(e);

                    if (this.draggingSelection && this.draggingAnchor) {
                        const rawX = x - this.draggingAnchor.offsetX;
                        const rawY = y - this.draggingAnchor.offsetY;
                        const snappedX = Math.round(rawX / 20) * 20;
                        const snappedY = Math.round(rawY / 20) * 20;
                        const deltaX = snappedX - this.draggingAnchor.startX;
                        const deltaY = snappedY - this.draggingAnchor.startY;

                        this.draggingSelection.forEach(entry => {
                            entry.node.x = entry.startX + deltaX;
                            entry.node.y = entry.startY + deltaY;
                        });

                    } else if (this.draggingCable) {
                        this.draggingCable.x = x;
                        this.draggingCable.y = y;
                    } else if (this.draggingParam) {
                        this.setParamValueFromPointer(this.draggingParam, x);
                    }

                    // Hover
                    this.hoveredPort = null;
                    if (this.draggingCable) {
                        for (let n of this.nodes) {
                            if (n === this.draggingCable.fromNode) continue;
                            for (let j = 0; j < n.inputs.length; j++) {
                                const p = n.getPortPos(true, j);
                                if (Math.hypot(x - p.x, y - p.y) < 15) {
                                    this.hoveredPort = { node: n, index: j, kind: 'audio' };
                                }
                            }
                            if (n.paramInputs) {
                                for (let j = 0; j < n.paramInputs.length; j++) {
                                    const pos = n.getParamInputPos(j);
                                    if (Math.hypot(x - pos.x, y - pos.y) < 15) {
                                        this.hoveredPort = { node: n, index: j, kind: 'param' };
                                    }
                                }
                            }
                        }
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.draggingCable && this.hoveredPort) {
                        this.connect(
                            this.draggingCable.fromNode,
                            this.draggingCable.fromPort,
                            this.hoveredPort.node,
                            this.hoveredPort.index,
                            this.hoveredPort.kind || 'audio'
                        );
                    }
                    this.draggingNode = null;
                    this.draggingCable = null;
                    this.draggingParam = null;
                    this.draggingSelection = null;
                    this.draggingAnchor = null;
                });

                window.addEventListener('mousemove', (e) => {
                    if (!this.isPanning || !this.panStart || !this.panStartOffset) return;
                    const dx = e.clientX - this.panStart.x;
                    const dy = e.clientY - this.panStart.y;
                    this.viewOffset.x = this.panStartOffset.x + dx;
                    this.viewOffset.y = this.panStartOffset.y + dy;
                    this.hoveredPort = null;
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button === 1 && this.isPanning) {
                        this.isPanning = false;
                        this.panStart = null;
                        this.panStartOffset = null;
                        this.canvas.style.cursor = 'default';
                    }
                    if (e.button === 0) {
                        if (this.draggingSelection || this.draggingCable || this.draggingParam) {
                            this.draggingSelection = null;
                            this.draggingAnchor = null;
                            this.draggingNode = null;
                            this.draggingCable = null;
                            this.draggingParam = null;
                            this.hoveredPort = null;
                        }
                    }
                });

                this.canvas.addEventListener('dblclick', (e) => {
                    const { x, y } = getMousePos(e);

                    for (let i = this.nodes.length - 1; i >= 0; i--) {
                        const n = this.nodes[i];
                        if (!n.params || !n.params.length) continue;
                        const isAudioSourceNode = n.type === 'audio-source' || n.type === 'sampler';
                        const paramBaseOffset = isAudioSourceNode ? 100 : 24;
                        const paramSpacing = n.paramSpacing || 48;
                        for (let idx = 0; idx < n.params.length; idx++) {
                            const sliderX = n.x + 10;
                            const sliderWidth = n.width - 20;
                            const slotTop = typeof n.getParamSlotTop === 'function'
                                ? n.getParamSlotTop(idx)
                                : n.y + n.headerHeight + paramBaseOffset + (idx * paramSpacing);
                            const captureTop = slotTop + 16;
                            const captureBottom = slotTop + paramSpacing;
                            if (x >= sliderX && x <= sliderX + sliderWidth && y >= captureTop && y <= captureBottom) {
                                if (this.resetParamToDefault(n, idx)) {
                                    return;
                                }
                            }
                        }
                    }

                    const connection = this.findConnectionAt(x, y, 10);
                    if (connection) {
                        const idx = this.connections.indexOf(connection);
                        this.disconnect(connection);
                        if (idx >= 0) this.connections.splice(idx, 1);
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    const { x, y } = getMousePos(e);
                    const connection = this.findConnectionAt(x, y, 10);
                    if (connection && connection.kind === 'param') {
                        e.preventDefault();
                        this.cycleParamConnectionMode(connection);
                        return;
                    }
                });
            }

            drawNode(n) {
                const ctx = this.ctx;
                const w = n.width;
                const h = n.height;
                const r = 6;
                const screenX = n.x + this.viewOffset.x;
                const screenY = n.y + this.viewOffset.y;

                const isSelected = this.selectedNodes.has(n);

                // Body
                ctx.fillStyle = '#2d2d2d';
                const isAudioSourceNode = n.type === 'audio-source' || n.type === 'sampler';
                const isActiveSource = n === this.lastAudioSourceNode && isAudioSourceNode;
                let strokeStyle = '#555';
                let strokeWidth = 1;
                if (isActiveSource) {
                    strokeStyle = '#00d2ff';
                    strokeWidth = 2;
                }
                if (isSelected) {
                    strokeStyle = '#ffd54f';
                    strokeWidth = 2;
                }
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = strokeWidth;
                ctx.beginPath();
                ctx.roundRect(screenX, screenY, w, h, r);
                ctx.fill();
                ctx.stroke();

                // Header
                ctx.fillStyle = isSelected ? '#474747' : '#404040';
                ctx.beginPath();
                ctx.roundRect(screenX, screenY, w, n.headerHeight, [r, r, 0, 0]);
                ctx.fill();

                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText(n.title, screenX + 10, screenY + 17);

                // Inputs
                n.inputs.forEach((inp, i) => {
                    const pos = n.getPortPos(true, i);
                    const sx = pos.x + this.viewOffset.x;
                    const sy = pos.y + this.viewOffset.y;
                    ctx.fillStyle = '#ff4d4d';
                    ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI * 2); ctx.fill();
                });

                // Outputs
                n.outputs.forEach((out, i) => {
                    const pos = n.getPortPos(false, i);
                    const sx = pos.x + this.viewOffset.x;
                    const sy = pos.y + this.viewOffset.y;
                    ctx.fillStyle = '#4dff88';
                    ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI * 2); ctx.fill();
                });

                if (isAudioSourceNode) {
                    const buttons = ['kick', 'snare', 'hh', 'sine', 'saw', 'square', 'triangle', 'noise', 'mic', 'custom'];
                    let bx = screenX + 10;
                    let by = screenY + n.headerHeight + 10;
                    const btnW = 60;
                    const btnH = 20;
                    const gap = 5;
                    let buttonsBottom = by;

                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    buttons.forEach(b => {
                        let fill = '#555';
                        if (b === 'mic') {
                            if (n.micActive) fill = '#2e7d32';
                            else if (n.micPending) fill = '#8c6d1f';
                            else if (n.micError) fill = '#8c1f1f';
                            else if (n.lastType === 'mic') fill = '#006d9c';
                        } else if (b === n.lastType) {
                            fill = '#006d9c';
                        }
                        ctx.fillStyle = fill;
                        ctx.fillRect(bx, by, btnW, btnH);
                        ctx.fillStyle = '#fff';
                        let label = b.toUpperCase();
                        if (b === 'mic') {
                            if (n.micActive) label = 'MIC ON';
                            else if (n.micPending) label = 'MIC...';
                            else if (n.micError) label = 'MIC ERR';
                        }
                        ctx.fillText(label, bx + btnW / 2, by + btnH / 2);
                        const bottom = by + btnH;
                        if (bottom > buttonsBottom) buttonsBottom = bottom;
                        bx += btnW + gap;
                        if (bx + btnW > screenX + w - 10) {
                            bx = screenX + 10;
                            by += btnH + gap;
                        }
                    });

                    const loadX = screenX + 10;
                    const loadY = buttonsBottom + gap;
                    const loadW = 90;
                    const loadH = 22;
                    ctx.fillStyle = '#444';
                    ctx.fillRect(loadX, loadY, loadW, loadH);
                    ctx.fillStyle = '#ccc';
                    ctx.fillText('LOAD FILE', loadX + loadW / 2, loadY + loadH / 2);

                    let statusY = loadY + loadH + 14;
                    if (n.micPending) {
                        ctx.fillStyle = '#ffd54f';
                        ctx.fillText('Mic: requesting...', loadX, statusY);
                        statusY += 12;
                    } else if (n.micActive) {
                        ctx.fillStyle = '#4dff88';
                        ctx.fillText('Mic: active', loadX, statusY);
                        statusY += 12;
                    } else if (n.micError) {
                        ctx.fillStyle = '#ff6b6b';
                        const message = typeof n.micError === 'string'
                            ? n.micError
                            : (n.micError && n.micError.message) ? n.micError.message : 'unavailable';
                        const display = message.length > 36 ? `${message.slice(0, 33)}...` : message;
                        ctx.fillText(`Mic: ${display}`, loadX, statusY);
                        statusY += 12;
                    }

                    ctx.textAlign = 'start';
                    ctx.textBaseline = 'alphabetic';
                }

                if (n.type === 'output' && n.analyser && this.audioCtx) {
                    const scopeX = screenX + 12;
                    const scopeY = screenY + n.headerHeight + 8;
                    const scopeW = Math.max(20, w - 24);
                    const scopeH = Math.max(16, Math.min(40, h - n.headerHeight - 16));

                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(scopeX, scopeY, scopeW, scopeH);
                    ctx.clip();

                    ctx.fillStyle = '#000';
                    ctx.fillRect(scopeX, scopeY, scopeW, scopeH);

                    n.analyser.getByteTimeDomainData(n.visualData);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#00d2ff';
                    ctx.beginPath();
                    const sliceWidth = scopeW * 1.0 / n.visualData.length;
                    let px = 0;
                    for (let i = 0; i < n.visualData.length; i++) {
                        const v = n.visualData[i] / 128.0;
                        const py = scopeY + (v * scopeH / 2);
                        const sx = scopeX + px;
                        if (i === 0) ctx.moveTo(sx, py);
                        else ctx.lineTo(sx, py);
                        px += sliceWidth;
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // Sliders
                const paramBaseOffset = isAudioSourceNode ? 100 : 24;
                const paramSpacing = n.paramSpacing || 40;
                const sliderTopOffset = 24;
                const sliderHeight = 6;
                const sliderPadding = 4;
                const sampleRate = this.audioCtx ? this.audioCtx.sampleRate : 44100;
                n.params.forEach((p, idx) => {
                    const slotTop = typeof n.getParamSlotTop === 'function'
                        ? n.getParamSlotTop(idx)
                        : n.y + n.headerHeight + paramBaseOffset + (idx * paramSpacing);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px sans-serif';
                    const effectiveVal = typeof p.effectiveValue === 'number' ? p.effectiveValue : p.value;
                    const hasMod = typeof p.value === 'number' && typeof effectiveVal === 'number' && Math.abs(effectiveVal - p.value) > 1e-6;

                    const formatValue = (val) => {
                        if (typeof val !== 'number' || Number.isNaN(val)) return `${val}`;
                        if (p.label === 'Waveform') {
                            const waveNames = ['Sine', 'Triangle', 'Saw', 'Square', 'Random'];
                            const idx = Math.max(0, Math.min(waveNames.length - 1, Math.round(val)));
                            return waveNames[idx];
                        }
                        if (p.label.includes('Delay (ms)')) {
                            const msVal = val.toFixed(2);
                            let text = `${msVal} ms`;
                            if (this.showDelaySamples) {
                                const samples = Math.round((val / 1000) * sampleRate);
                                text += ` (${samples} samples)`;
                            }
                            return text;
                        }
                        if (p.label.includes('Time (s)')) {
                            const secVal = val.toFixed(3);
                            let text = `${secVal} s`;
                            if (this.showDelaySamples) {
                                const samples = Math.round(val * sampleRate);
                                text += ` (${samples} samples)`;
                            }
                            return text;
                        }
                        if (p.label.includes('Hz')) {
                            const decimals = val >= 10 ? 1 : 2;
                            return `${val.toFixed(decimals)} Hz`;
                        }
                        const magnitude = Math.abs(val);
                        if (magnitude > 0 && magnitude < 0.001) {
                            return val.toExponential(2);
                        }
                        const decimals = magnitude >= 10 ? 2 : (magnitude >= 1 ? 3 : 4);
                        const formatted = parseFloat(val.toFixed(decimals));
                        return formatted === 0 ? '0' : formatted.toString();
                    };

                    const baseText = formatValue(p.value);
                    const effectiveText = formatValue(effectiveVal);
                    const displayText = hasMod ? `${baseText} -> ${effectiveText}` : baseText;
                    const slotTopScreen = slotTop + this.viewOffset.y;
                    const sliderX = screenX + 10;
                    const sliderWidth = w - 20;
                    const sliderY = slotTopScreen + sliderTopOffset;
                    const sliderMidY = sliderY + sliderHeight / 2;
                    const textY = slotTopScreen + 12;
                    ctx.fillText(`${p.label}: ${displayText}`, screenX + 10, textY);

                    if (n.paramInputs && n.paramInputs[idx]) {
                        const paramPos = n.getParamInputPos(idx);
                        const spx = paramPos.x + this.viewOffset.x;
                        const spy = paramPos.y + this.viewOffset.y;
                        const portRadius = 5;
                        ctx.fillStyle = '#ffd54f';
                        ctx.beginPath();
                        ctx.arc(spx, spy, portRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#b8860b';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(spx, spy, portRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.fillStyle = '#333';
                    ctx.fillRect(sliderX, sliderY, sliderWidth, sliderHeight);

                    let pct;
                    if (p.scale === 'log') {
                        pct = AudioUtils.fromLog(p.value, p.min, p.max);
                    } else if (p.scale === 'signedPow') {
                        pct = this.mapSignedPowValueToNorm(p, p.value);
                    } else {
                        const range = p.max - p.min;
                        pct = range === 0 ? 0 : (p.value - p.min) / range;
                    }
                    pct = Math.max(0, Math.min(1, pct));

                    const knobHalf = 6;
                    const knobX = sliderX + pct * sliderWidth;
                    const clampedKnobX = Math.min(sliderX + sliderWidth - knobHalf, Math.max(sliderX + knobHalf, knobX));

                    ctx.fillStyle = '#00d2ff';
                    ctx.fillRect(clampedKnobX - knobHalf, sliderY - sliderPadding, knobHalf * 2, sliderHeight + sliderPadding * 2);
                });
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
            }

            drawCable(connection, x1, y1, x2, y2, active) {
                const ctx = this.ctx;
                const sx1 = x1 + this.viewOffset.x;
                const sy1 = y1 + this.viewOffset.y;
                const sx2 = x2 + this.viewOffset.x;
                const sy2 = y2 + this.viewOffset.y;
                ctx.beginPath();
                const cp1x = sx1 + Math.abs(sx2 - sx1) * 0.5;
                const cp2x = sx2 - Math.abs(sx2 - sx1) * 0.5;
                ctx.moveTo(sx1, sy1);
                ctx.bezierCurveTo(cp1x, sy1, cp2x, sy2, sx2, sy2);
                if (active) {
                    ctx.strokeStyle = '#fff';
                } else if (connection && connection.kind === 'param') {
                    const mode = connection.mode || 'multiply';
                    if (mode === 'add') ctx.strokeStyle = '#7cb5ff';
                    else if (mode === 'override') ctx.strokeStyle = '#ff8a65';
                    else ctx.strokeStyle = '#ffd54f';
                } else {
                    ctx.strokeStyle = '#888';
                }
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            loop() {
                const now = performance.now();
                const delta = Math.min(0.1, Math.max(0, (now - this.lastTickTime) / 1000));
                if (delta > 0) {
                    this.dynamicNodes.forEach(node => {
                        if (typeof node.tick === 'function') node.tick(delta, now / 1000);
                    });
                }
                this.lastTickTime = now;

                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const gs = 20;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.beginPath();

                const startX = ((Math.floor((-this.viewOffset.x) / gs) - 1) * gs) + this.viewOffset.x;
                for (let x = startX; x < this.canvas.width + gs; x += gs) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                }

                const startY = ((Math.floor((-this.viewOffset.y) / gs) - 1) * gs) + this.viewOffset.y;
                for (let y = startY; y < this.canvas.height + gs; y += gs) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                }

                ctx.stroke();

                this.connections.forEach(c => {
                    const p1 = c.fromNode.getPortPos(false, c.fromPort);
                    const p2 = c.kind === 'param'
                        ? c.toNode.getParamInputPos(c.toPort)
                        : c.toNode.getPortPos(true, c.toPort);
                    this.drawCable(c, p1.x, p1.y, p2.x, p2.y, false);
                });

                if (this.draggingCable) {
                    const p1 = this.draggingCable.fromNode.getPortPos(false, this.draggingCable.fromPort);
                    this.drawCable(null, p1.x, p1.y, this.draggingCable.x, this.draggingCable.y, true);
                }

                this.nodes.forEach(n => this.drawNode(n));
                requestAnimationFrame(() => this.loop());
            }
        }

        const app = new App();

    </script>
</body>

</html>